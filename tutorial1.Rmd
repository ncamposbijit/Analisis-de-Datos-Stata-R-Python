# Tutorial 1: Data Analysis with R

These notes have been updated and adapted for the course ECON 326: Introduction to Econometrics II, an undergraduate course at the University of British Columbia (UBC), 2026. These are the notes for the tutorial 1. This is an introduction to R and R Studio. 
## Introduction to R and RStudio

This chapter introduces the basic workflow for working with R through RStudio. The goal is not only to learn *commands*, but also to develop good habits for writing clean, reproducible, and well-documented code.

### Why use R?

R is one of the most widely used programming languages for data analysis in Economics and the Social Sciences. Its main advantages are:

- **Open source:** R is free and has an active community that constantly develops new tools.
- **Versatility:** it supports statistical and econometric analysis, data cleaning, visualization, and automation (including tasks like web scraping).
- **Reproducibility:** scripts and reports allow you to document and replicate results reliably.
- **Labor market value:** open-source programming languages are increasingly demanded across research and industry.

In this course we will treat R not as a “calculator”, but as a programming language: we will write code, create objects, use functions systematically, and build routines that scale to larger projects.

---

### Key concepts (vocabulary of the course)

Before writing code, it is important to define the core terms that will appear throughout the course:

- **RStudio:** a Graphical User Interface (GUI) designed to make working with R easier.
- **Objects:** anything you store in memory (datasets, variables, lists, plots, models, etc.).
- **Functions:** operations that take inputs and return outputs (e.g., `mean(x)`, `lm(y ~ x)`).
- **Packages:** collections of functions grouped by purpose (e.g., `dplyr`, `ggplot2`, `rio`).
- **Scripts / Code:** files containing the commands that define your analysis pipeline.

---

### Learning resources

To learn R efficiently, you should rely on three types of resources: cheat sheets, forums, and structured books.

::: {style="text-align: justify"}
- **Cheat sheets:** short summaries of commands and workflows.  
  Available at: <https://www.rstudio.com/resources/cheatsheets/>
:::

- **Forums and websites:**
  - Stack Overflow: <https://stackoverflow.com/questions/tagged/r>
  - Medium: <https://preettheman.medium.com/awesome-tricks-every-r-coder-should-know-c4220cd2cfbc>
  - Posit Blog (formerly RStudio): <https://posit.co/>

- **Books:**
  - *R for Data Science*: <https://r4ds.had.co.nz/>
  - Posit resources in Spanish: <https://posit.co/resources/videos/>
  - Bookdown: <https://bookdown.org/>

---

### RStudio interface

RStudio is a convenient “vehicle” for working with R. The interface usually displays **four main panels**, which help you organize your work:

- **Scripts (Source):** where you write and save code.
- **Console:** where R runs commands and prints results.
- **Environment / History:** where you see the objects created in memory.
- **Files / Plots / Packages / Help:** tools to navigate folders, view plots, manage packages, and read documentation.

A key takeaway is that most of your work should live in the **Script**, not in the Console. The Console is useful for quick checks, but scripts are what ensure reproducibility.

You can customize RStudio via: **Tools → Global Options** (font size, theme, layout, etc.). The purpose is to make your workflow as intuitive and efficient as possible.

---

## Writing code: comments, structure and cleaning the environment

### Comments

Good code is code that other people (including “future you”) can understand. Comments are essential to explain *why* you do something, not only *what* you do.

To write comments in R scripts, use `#`. To comment multiple lines at once use:

- `Ctrl + Shift + C` (Windows)
- `Cmd + Shift + C` (Mac)

A very useful reference for best practices is:  
[Code and Data for the Social Sciences: A Practitioner's Guide](https://web.stanford.edu/~gentzkow/research/CodeAndData.pdf)

### Outlines (code indexing)

RStudio allows you to structure scripts using headings. This creates an outline that helps navigation in long files.

- Open outline: `Ctrl + Shift + O`

Headings can be hierarchical:

```{r message=FALSE}
# The most important
## This is a bit less important
### This is a bit less important than the previous one
#### The least important
```

Keeping the outline updated is not optional: as the script grows, the outline becomes one of the main tools to navigate your code efficiently. If headings are outdated or inconsistent, the outline loses its usefulness and long scripts become harder to maintain.

---

### Cleaning in R: environment vs console

When working in R, it is important to distinguish between two different things:

1. **The environment (memory):** where R stores the objects you create (datasets, vectors, models, plots, etc.).
2. **The console (screen):** where commands and results are printed.

Cleaning the environment is about deleting objects stored in memory.  
Cleaning the console is only about making the screen look “clean” — it does not delete anything.

---

Remove all objects from the environment

```{r message=FALSE}
rm(list = ls())
```
Remove only one object

```{r message=FALSE}
# rm(data1)
```

## Package installation, libraries and help

In R, most of the tools we use are contained in **packages**. A package is simply a **collection of functions** designed for a specific purpose (e.g., data cleaning, plotting, importing files, estimation).  

A key distinction is the following:

- Packages are **installed once** on your computer.
- Packages must be **loaded every time** you open a new R session in order to use them.

This difference is crucial: many beginner errors come from confusing “installing” with “loading”.

### Libraries

There are two standard ways to install packages in RStudio:

1. Using the *Packages* tab in the bottom-right panel.
2. Using commands directly in R.

```{r message = FALSE, warning = FALSE, results="hide"}
install.packages("dplyr")
```

Many packages at the same time: 

```{r, eval=FALSE}
install.packages(c("dplyr","ggplot2","rio"))
```

Common error: 
```{r, eval=FALSE}
install.packages(dplyr, "ggplot2")
```

In general, it is a good idea to install them at the beginning of your work, since we commonly use the same libraries when doing data analysis. With this function, we tell R to install the package if it is not installed (something typical when we switch computers):

```{r, eval=FALSE}
if(!require(dplyr)) {install.packages("dplyr")}
```

Load libraries: 

```{r, eval=FALSE}
library(dplyr)
```

If we want to see what is inside each package:

```{r, eval=FALSE}
ls("package:dplyr", all = TRUE) #ls = list objects
```

**Important**: the package must be installed once, but loaded every time it is used. There are often updates. To check and install them:


```{r, eval=FALSE}
update.packages()
```

Alternatively, I can link a package to a function using `::`. If I do this, it is not necessary to load the library in order to use that specific function. However, the recommended practice is to load all the libraries of the packages I will use at the beginning.

### Help function 

About a specific function: 

```{r, eval=FALSE}
help(mean) 
?mean 
mean 
sd
```

About a specific package: 

```{r, eval=FALSE}
help("dplyr") 
library(help="dplyr")
```

### Useful *Shortcuts*

-   `Esc`: interrupt the current command
-   `Ctrl + s`: save
-   `tab`: autocomplete
-   `Ctrl + Enter`: run line
-   `Ctrl + Shift + C`: comment/uncomment
-   `<-`: Alt + - / option + -
-   `%>%`: Ctrl + Shift + M (*pipe*)
-   `Ctrl + l`: clear console
-   `Ctrl + Alt + b`: run everything up to here (the arrow keys in the console allow you to view the most recent commands used)
-   `Shift + lines`: select multiple lines
-   `Ctrl + f`: find/replace
-   `Ctrl + Up Arrow` (in the console): view previously used commands


#### Identify the package of a function

Sometimes we want to know which package a given function belongs to. For that, check:
<https://sebastiansauer.github.io/finds_funs/>
`

Note that a `+` sign appears in the console. In these cases, RStudio stops because you probably forgot a `)` or a `#`. You must correct the error, run the code again, and then press `Esc` in the console to continue executing commands.

## R Markdown - Reproducible research

R Markdown is one of the most useful tools in applied data analysis because it allows you to combine **explanatory text** with **executable code** in a single document. The key idea is simple:

> You write the analysis once, and every time the data changes, you can re-run the document to automatically update tables, figures, and results.

This makes your work:

- **Automatic:** outputs are generated by code (not manually copied).
- **Reproducible:** anyone can re-run the document and obtain the same results.
- **Well documented:** results are always accompanied by explanations, interpretation, and methodology.

In practice, an R Markdown file (`.Rmd`) works like a hybrid between a report and a script: it contains written text (like a Word document) and chunks of code (like an R script). When you compile (“knit”) the file, R executes the code chunks and inserts the results (tables, plots, numbers) directly into the final report.

---

### What can R Markdown produce?

An `.Rmd` file can generate many different types of outputs, such as:

- **Word reports** (`.docx`)
- **PDF reports** (`.pdf`)
- **HTML reports** (`.html`)
- **Presentations** (slides)
- **Dashboards** (interactive documents)

More importantly, an `.Rmd` file can include all elements that typically appear in a data analysis:

- plain text explanations
- R code chunks
- tables
- plots
- regression output
- automatically updated statistics (means, SDs, p-values, etc.)

---

### When is R Markdown especially useful?

R Markdown is particularly valuable in two common situations:

1. **Routine reports**  
   Example: a weekly report with updated descriptive statistics and graphs.  
   Instead of rewriting the report every week, you update the data and re-knit.

2. **Reports for subsets of a dataset**  
   Example: a dataset contains several countries. You want one report per country.  
   With R Markdown, you can parameterize the report and automatically generate one output per country.

The general lesson is: if you are repeating work manually, it can probably be automated with R Markdown.

---

## Basic concepts

To understand R Markdown, you need to distinguish the following components:

### Markdown (`.md`)

**Markdown** is a simple plain-text language to format documents. For example:

- `# Title` creates a section title
- `**bold**` produces bold text
- lists, links, and images are easy to write

Markdown files have extension `.md`.

### R Markdown (`.Rmd`)

**R Markdown** extends Markdown by allowing you to embed R code directly into the document. Files have extension `.Rmd`.

The most important feature is that R code is executed and its output is included in the report. This is what makes the document **dynamic** and **reproducible**.

### knitr

`knitr` is the R package responsible for:

- reading the `.Rmd` file
- identifying code chunks
- executing the R code
- inserting the results (tables/figures/output) into the document

In other words: `knitr` is the engine that turns the `.Rmd` file into a report.

### Pandoc

Pandoc is the tool that converts the report into a final format such as PDF, Word, or HTML.

It takes the document produced by `knitr` and transforms it into a clean formatted file.  
Pandoc is installed automatically with RStudio, so you do not need to install it manually.

---

### Process (how everything works together)

The workflow is:

1. You write text and R code in a single `.Rmd` document.
2. `knitr` executes the code chunks.
3. Pandoc converts the final output into PDF/Word/HTML.

![Source: https://rmarkdown.rstudio.com/authoring/quick_tour.html](01figuras/C8.1.png)

---

### Your first R Markdown file

To create your first `.Rmd` document in RStudio:

- Go to: **File → New File → R Markdown**
- Choose the output format: report / presentation / dashboard
- Set the document title and author

![](01figuras/C8.2.png)  
![](01figuras/C8.3.png)

The most common starting point is a simple report that outputs to HTML or Word.

---

### Working directory (critical detail)

A frequent source of confusion in R Markdown is the **working directory**.

The general rule is:

> The working directory of an `.Rmd` file is the folder where the `.Rmd` file is saved.

This means that if your `.Rmd` file is saved in a folder, R will look for datasets and external files in the **same folder** (unless you specify full paths).

For this course, we will keep things simple:
- store your data in the same folder as the `.Rmd` file
- avoid complicated paths until you gain familiarity

This is a best practice for beginners because it reduces file-loading errors.

---

### Components of an R Markdown file

An R Markdown file has three main components:

1. **YAML header**  
   A block at the top of the file containing metadata (title, author, output type).

2. **Markdown text**  
   Where you write narrative explanations: motivation, steps, interpretation.

3. **Code chunks**  
   Blocks of R code used for loading packages, importing data, transforming variables, estimating models, and generating plots.

![](01figuras/C8.4.png)

A code chunk looks like this:


A typical workflow is:

- YAML sets format + structure
- Markdown text explains what you are doing
- code chunks do the analysis and generate outputs

![](01figuras/C8.5.png)

---

### Why is this powerful?

In Word/Excel workflows, people often:
- run regressions in one place,
- copy results into a document,
- manually update tables and plots.

This is slow and error-prone.

With R Markdown:
- your report is generated directly from code,
- results are always consistent with data,
- there is no manual copy/paste.

That is why R Markdown is considered a core tool for reproducible research.

 ### Working directory

- The working directory of a `.Rmd` file is the folder where the file is saved.
- Therefore, R will search for files in the same folder where the `.Rmd` file is stored.
- For this exercise, we will simply keep the data we use in the same folder as the `.Rmd` file.

### Components of R Markdown

![](01figuras/C8.4.png)

- YAML: set title, date, and output type.
- Markdown text: write narrative text.
- Code chunk: load packages, data, and create visualizations.

![](01figuras/C8.5.png)

## Object manipulation

#### Using R as a calculator / running commands

You can run commands in R in an interactive way, just like using a calculator. To do this, select the line(s) of code you want to execute and press:

- `Ctrl + Enter` (Windows)
- `Cmd + Enter` (Mac)

This allows you to run commands separately (one line at a time or a selected block), without executing the entire script.


```{r}
2+2 
3*5^(1/2)
```

#### Running all instructions

To execute the entire script (i.e., run all commands in the file at once), you have several options:

- Click **Source** (top-right of the Script panel) to run the whole script.
- Use the menu: **Code → Run Region → Run All**.
- Shortcut: `Ctrl + Alt + R` (Windows) / `Cmd + Option + R` (Mac)

Running the full script is useful when you want to reproduce the complete workflow from start to finish (e.g., cleaning data, generating tables, producing plots).


```{r}
2+2 ; 3*5^(1/2)
3+4 
5*4 
8/4 
6^7
6^77

log(10) 
log(1)

sqrt(91) # raiz cuadrada

round(7.3) # redondear
```

Even large operations can be executed this way. For example, you can select and run a full block of code (data imports, transformations, loops, regressions, plots) instead of running commands one by one. This is especially useful when your analysis requires multiple steps that must be executed in the correct order.


```{r}
sqrt(91) + 4892788*673 - (log(4)*round(67893.9181, digits = 2))
```

You can even work with **complex numbers** (imaginary numbers) in R.  
In R, the imaginary unit is written as `i`, and complex numbers can be used in arithmetic operations just like real numbers.

Example:

```{r}
2i+5i+sqrt(25i)
```

#### Object creation: assignment and functions

In R, we create objects using the assignment operator `<-`. This is one of the most important operations in the language, because almost everything we do in R consists of creating and transforming objects (vectors, datasets, models, plots, etc.).  

It is also possible to assign values using `=`, but this is **not recommended** in general practice, since it can be confusing (especially inside functions). The recommended standard in most applied work is to use `<-`.

```{r}
y <- 2 + 4 
y
```

## Understanding Assignments and Functions in R

Assignments in R are silent operations. When we create an assignment, it stores the value but does not automatically display it in the console. To see the result of an assignment, we must explicitly call the object by typing its name or using the `print()` function.

While simple assignments are straightforward, the real power of R lies in generating assignments through functions. Functions are the central component of working with R. Some functions come pre-installed with the base R installation, while others must be obtained from external packages. Additionally, users can write their own custom functions. Functions are typically written with parentheses, such as `filter()`. In some cases, functions are associated with specific packages and are referenced using the double colon notation, for example `dplyr::filter()`.

Let's explore how functions work through several examples. First, we can apply a simple mathematical function:

```{r}
sqrt(49)
```

This calculates the square root of 49. We can also apply functions to datasets. For instance, we can obtain summary statistics for a variable within a dataset:

```{r}
summary(mtcars$mpg)
```

The `mtcars` dataset comes pre-installed with R and contains information about various car models. To see other datasets that come bundled with R, we can use the `data()` function:

```{r}
data()
```

### Working with Vectors and Arithmetic Functions

We can create objects by assigning values to them and then combine these objects into vectors. A vector is a fundamental data structure in R that contains elements of the same type:

```{r}
x <- 2
y <- 3
z <- c(x, y)
z
```

Here, we create two individual numeric objects (`x` and `y`) and then combine them into a vector `z` using the concatenate function `c()`. Once we have a vector, we can apply various statistical functions to it:

```{r}
mean(z)
median(z)
```

These functions calculate the arithmetic mean and median of the values in the vector, respectively.

### Creating Relationships Between Objects

We can create new objects based on calculations performed on existing objects. For example, we can store the mean of a vector as a new object:

```{r}
w <- mean(z)
```

We can also create objects through arithmetic operations:

```{r}
a <- 3 + 10
b <- 2 * 4
```

R allows us to perform logical comparisons between objects:

```{r}
a > b
```

This returns a logical value (`TRUE` or `FALSE`) indicating whether `a` is greater than `b`.

### The Silent Nature of Assignments

As mentioned earlier, assignments do not produce output unless we explicitly request it. To display the contents of an object, we simply type its name or use the `print()` function:

```{r}
a
b
# alternatively, use print
print(a)
print(b)
```

### Building Complex Objects from Functions

We can build more complex objects by combining multiple operations. For instance, we can create a vector from previously defined objects and calculate its mean:

```{r}
valores <- c(a, b)
promedio <- mean(valores)
print(promedio)
promedio
```

Let's work through another example where we calculate the mean of two values:

```{r}
a <- 2
b <- 5
valores1 <- c(a, b)
promedio1 <- mean(valores1)
print(promedio1)
```

To clear our workspace and remove specific objects, we can use the `rm()` function:

```{r}
rm(list = ls())
rm(promedio)
```

The first command removes all objects from the environment, while the second removes a specific object.

### Working with Real Data: Education and Income Example

Proper spacing and organization of code is essential for readability and maintenance. Let's create two vectors representing education (in years) and income for ten individuals using the concatenate function `c()`:

```{r}
educ <- c(8, 12, 8, 11, 16, 14, 8, 10, 14, 12)
ingreso <- c(325, 415, 360, 380, 670, 545, 350, 420, 680, 465)
```

Once we have these vectors, we can calculate various descriptive statistics. We can compute the mean income, the standard deviation of income, and the correlation between education and income:

```{r}
mean(ingreso)
promedioingreso <- mean(ingreso)

sd(ingreso)
sdingreso <- sd(ingreso)

cor(educ, ingreso)
coreduing <- cor(educ, ingreso)
```

The mean provides the average income, the standard deviation measures the dispersion of income values around the mean, and the correlation coefficient quantifies the strength and direction of the linear relationship between education and income.

### Visualizing the Relationship

To visually examine the relationship between education and income, we can create a scatter plot:

```{r}
plot(educ, ingreso)
```

This produces a graph with education on the x-axis and income on the y-axis, allowing us to see the pattern of association between these two variables.

### Estimating a Linear Regression Model

Finally, we can formally model the relationship between education and income using linear regression. The `lm()` function estimates a linear model where income is the dependent variable and education is the independent variable:

```{r}
lm(ingreso ~ educ)
```

This function returns the estimated coefficients for the linear model, providing us with the intercept and the slope coefficient for education. The slope coefficient indicates how much income is expected to change for each additional year of education.

## Object Naming and Types

### Naming Objects

The following exercise helps us understand the rules for valid variable names in R.

**Exercise: Valid Variable Names**

Consider the following examples. Which of these are valid variable names in R?

```{r}
# min_height      # Valid: uses underscore
# max.height      # Valid: uses dot
# _age            # Invalid: starts with underscore
# .mass           # Valid: starts with dot (but creates hidden variable)
# MaxLength       # Valid: uses camel case
# Min-length      # Invalid: uses hyphen (minus sign)
# 2widths         # Invalid: starts with number
# Calsius2kelvin  # Valid: number in middle is allowed
```

In R, variable names must follow these rules: they can contain letters, numbers, dots, and underscores, but they must start with a letter or a dot (if starting with a dot, the second character cannot be a number). Variable names cannot contain spaces or special characters like hyphens, and they cannot start with numbers or underscores.

### Types of Objects

#### Vectors

R operates component by component, which makes it very straightforward to work with vectors and matrices. Vectors are one-dimensional arrays that can hold numeric data, character data, or logical data, but all elements must be of the same type.

To create a vector, we use the `c()` function (which stands for "concatenate" or "combine"):

```{r}
x <- c(1, 2, 3, 4, 5)
# or alternatively
y <- c(6:8)
```

Let's examine what happens when we add vectors together:

```{r}
z <- x + y
z
```

Now, let's consider two vectors of different lengths:

```{r}
x <- c(1:4)
y <- c(1:3)
```

We can check the length of each vector using the `length()` function:

```{r}
length(x)
length(y)
```

What happens when we try to add vectors of different lengths?

```{r}
z <- x + y
z
```

**IMPORTANT**: In this case, R performs the operation anyway, but it gives us a warning that the lengths differ. R uses "vector recycling," where the shorter vector is repeated to match the length of the longer vector. A crucial characteristic of vectors is that they can only concatenate elements of the same type; otherwise, R will coerce all elements to a common type (usually character if there's a mix).

Let's explore more vector operations:

```{r}
x <- rep(1.5:9.5, 4)  # generates repetitions of the defined values
y <- c(20:30)
x1 <- c(1, 2)
x2 <- c(3, 4)
x3 <- c(x1, x2)
x4 <- c(c(1, 2), c(3, 4))
```

##### Subsetting Vectors

We can extract specific elements from a vector using square bracket notation:

```{r}
y[3]         # get the third element
y[2:4]       # get elements 2 through 4
y[4:2]       # get elements in reverse order (4, 3, 2)
y[c(2, 6)]   # get elements 2 and 6
y[c(2, 16)]  # attempt to get element 16 (returns NA if out of bounds)
```

#### Matrices

Matrices are two-dimensional arrays where all elements must be of the same type. They are particularly useful for mathematical operations and organizing data in rows and columns.

##### Defining Matrices

The general syntax for creating a matrix is:

```{r, eval=FALSE}
my.matrix <- matrix(vector,
                    ncol = num_columns,
                    nrow = num_rows,
                    byrow = logical_value,
                    dimnames = list(vector_row_names,
                                   vector_column_names))
```

To create matrices, we use the `matrix()` function:

```{r}
x <- matrix(data = c(1, 2, 3, 4),
            nrow = 2,
            ncol = 2)

x1 <- matrix(c(1, 2, 3, 4),
             2,
             2)
```

While it is not necessary to explicitly write `data=`, doing so improves code readability and makes the intent clearer.

```{r}
x
x1
```

Note that by DEFAULT, R fills the matrix column by column. We can explicitly specify that we want to fill the matrix row by row using the `byrow` argument:

```{r}
y <- matrix(data = c(1:4),
            nrow = 3,
            ncol = 2,
            byrow = TRUE)
y
```

We can determine the dimensions of a matrix using the `dim()` function:

```{r}
dim(y)
dim(y)[1]  # number of rows
dim(y)[2]  # number of columns

y <- matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2, byrow = 2)
y
```

If the vector is shorter than the matrix dimensions, R will recycle the values to fill the matrix:

```{r}
y <- matrix(c(1, 2, 3, 4), nrow = 2, ncol = 3, byrow = 2)
y
```

Note that the order in any matrix is always **rows × columns**. We can also omit either the number of rows or columns, and R will calculate the missing dimension:

```{r}
y <- matrix(c(1:4), 2, byrow = T)
y
```

When creating empty matrices, we must define the dimensions:

```{r}
y <- matrix(nrow = 3, ncol = 3)
y  # useful for loops where we fill values iteratively
```

##### Naming Rows and Columns

We can assign names to rows and columns directly in the `matrix()` function:

```{r}
y <- matrix(c(1:4), 2, byrow = FALSE,
            dimnames = list(c("X1", "X2"), c("Y1", "Y2")))
y
```

Alternatively, we can use the `colnames()` and `rownames()` functions:

```{r}
colnames(x) <- c("Variable 1", "Variable 2")
rownames(x) <- c("a1", "a2")
x
```

##### Adding Rows or Columns to a Matrix

Let's create a new vector to add to our matrix:

```{r}
w <- c(5, 6)
```

We can combine matrices and vectors using rows (note that the vector name becomes the row name):

```{r}
z <- rbind(x, w)
z
```

We can also combine using columns:

```{r}
z <- cbind(x, w)
z
```

What happens if they have different numbers of rows and/or columns? R will recycle the shorter vector or observation to match the longer dimension:

```{r}
x <- matrix(c(1:9), 3)
x
y <- c(5, 6)
y

z <- rbind(x, y)
z
```

##### Converting Vectors to Matrices

We can convert a vector to a matrix by assigning dimensions:

```{r}
x <- 1:10
x

dim(x) <- c(2, 5)
x
```

##### Transposing Matrices

We can transpose a matrix (swap rows and columns) using the `t()` function:

```{r}
x <- matrix(c(1:9), 3)
x_transposed <- t(x)
x_transposed
```

##### Subsetting Matrices

We can extract specific elements, rows, or columns from a matrix. For example, to get the second and fourth elements of the second row:

```{r}
M <- matrix(1:8, nrow = 2)
M
M[1, 1]       # element in first row, first column
M[1, ]        # entire first row
M[, 2]        # entire second column
M[2, c(2, 4)] # second and fourth elements of the second row
```

Matrix subsetting uses the format `[row, column]`, where leaving either position blank returns all rows or all columns, respectively.


## Arrays

Arrays are multidimensional data structures that extend the concept of matrices. While matrices are two-dimensional, arrays can have three or more dimensions. They are particularly useful when working with data that naturally has multiple dimensions, such as time series data across different regions and variables.

### Creating Arrays

The basic syntax for creating an array is: `array(data, dim, dimnames)`

```{r arrays-basic}
# Creating a simple 3D array
my_array <- array(1:24, c(2, 4, 3))
my_array
```

The array above has dimensions 2 × 4 × 3, meaning it has 2 rows, 4 columns, and 3 "layers" or levels in the third dimension.

### Adding Dimension Names

Dimension names make arrays much easier to interpret and work with:

```{r arrays-dimnames}
# Define names for each dimension
dim1 <- c("row1", "row2")
dim2 <- c("col1", "col2", "col3", "col4")
dim3 <- c("level1", "level2", "level3")

# Create array with named dimensions
my_array <- array(1:24, c(2, 4, 3),
                  dimnames = list(dim1, dim2, dim3))
my_array
```

### Accessing Array Elements

Arrays can be subset using square brackets, similar to matrices but with additional dimensions:

```{r arrays-subset}
# Access a single element: row 1, column 2, level 3
my_array[1, 2, 3]

# Access entire slices
my_array[, , 1]  # All of level 1
my_array[1, , ]  # All of row 1 across all levels

# Access by dimension names
my_array["row1", "col2", "level3"]
```

## Lists

Lists are R's most flexible data structure. Unlike vectors, which must contain elements of the same type, lists can contain elements of different types, including other lists, vectors, matrices, dataframes, and even functions.

### Creating Lists

```{r lists-create}
# Create a heterogeneous list
my_list <- list(
  numbers = c(1, 2, 3),
  text = "Hello R",
  matrix = matrix(1:6, nrow = 2),
  flag = TRUE
)

my_list
```

### Accessing List Components

Lists have three main ways to access their components:

```{r lists-access}
# Method 1: Double brackets [[ ]] - extracts the element itself
my_list[[1]]  # Returns the numeric vector

# Method 2: Dollar sign $ - access by name
my_list$text  # Returns "Hello R"

# Method 3: Single brackets [ ] - returns a sublist
my_list[1]    # Returns a list containing the first element

# Accessing nested elements
my_list[[3]][1, 2]  # Second element of first row in the matrix
```

### Adding and Removing List Elements

```{r lists-modify}
# Adding new components
my_list$new_vector <- c(10, 20, 30)

# Removing components (set to NULL)
my_list$flag <- NULL

# View updated structure
str(my_list)
```

## Data Frames

Data frames are the workhorse data structure for statistical analysis in R. They are similar to matrices but can contain columns of different types, making them perfect for representing datasets where variables may be numeric, character, or logical.

### Creating Data Frames

```{r dataframes-create}
# Create a data frame
df <- data.frame(
  ID = 1:5,
  Name = c("Alice", "Bob", "Charlie", "Diana", "Eve"),
  Age = c(25, 30, 35, 28, 32),
  Employed = c(TRUE, TRUE, FALSE, TRUE, TRUE)
)

df
```

### Exploring Data Frame Structure

```{r dataframes-explore}
# View structure
str(df)

# Dimensions
dim(df)
nrow(df)
ncol(df)

# Column names
names(df)
colnames(df)

# Summary statistics
summary(df)

# First and last rows
head(df, 3)
tail(df, 2)
```

### Subsetting Data Frames

Data frames combine the subsetting behavior of both matrices and lists:

```{r dataframes-subset}
# Accessing columns
df$Name           # By name with $
df[, "Age"]       # By name with brackets
df[, 3]           # By position

# Accessing rows
df[2, ]           # Second row

# Accessing specific cells
df[2, 3]          # Row 2, Column 3
df[2, "Age"]      # Same, using column name

# Subsetting with conditions
df[df$Age > 28, ]                    # Rows where Age > 28
df[df$Employed == TRUE, c("Name", "Age")]  # Employed people's names and ages
```

### Tibbles: Modern Data Frames

The `tibble` package (part of tidyverse) provides an enhanced version of data frames:

```{r tibbles, message=FALSE}
library(tibble)

# Create a tibble
tb <- tibble(
  ID = 1:5,
  Name = c("Alice", "Bob", "Charlie", "Diana", "Eve"),
  Age = c(25, 30, 35, 28, 32),
  Employed = c(TRUE, TRUE, FALSE, TRUE, TRUE)
)

tb

# Tibbles have better printing and more consistent behavior
```

## Data Types and Type Checking

Understanding data types is crucial for avoiding errors and writing robust R code.

### Main Data Types

```{r datatypes}
# Character
char_var <- "Hello"
class(char_var)

# Numeric (double precision)
num_var <- 3.14
class(num_var)

# Integer
int_var <- 42L
class(int_var)

# Logical
log_var <- TRUE
class(log_var)

# Complex
complex_var <- 3 + 2i
class(complex_var)
```

### Type Checking Functions

```{r type-checking}
x <- 42

# Specific type checks
is.numeric(x)
is.integer(x)
is.character(x)
is.logical(x)

# Convert x to integer
x_int <- as.integer(x)
is.integer(x_int)
```

### Type Coercion

When R combines different types, it follows a coercion hierarchy:
logical → integer → numeric → complex → character

```{r coercion}
# Combining logical and numeric
c(TRUE, 1, 2)  # TRUE becomes 1

# Combining numeric and character
c(1, 2, "three")  # Numbers become characters

# Explicit coercion
as.character(42)
as.numeric("3.14")
as.logical(1)  # Non-zero numbers become TRUE
```

### Missing Values

R uses `NA` (Not Available) to represent missing values.

```{r missing-values}
# Creating vectors with missing values
x <- c(1, 2, NA, 4, NA)

# Detecting missing values
is.na(x)

# Counting missing values
sum(is.na(x))

# Removing missing values
x[!is.na(x)]
na.omit(x)

# Many functions have na.rm parameter
mean(x)              # Returns NA
mean(x, na.rm = TRUE)  # Calculates mean ignoring NAs
```

### Conditional Statements

Conditional statements allow your code to make decisions and execute different code based on conditions.

## If-Else Statements

```{r conditionals-basic}
# Basic if statement
x <- 10

if (x > 5) {
  print("x is greater than 5")
}

# If-else
x <- 3

if (x > 5) {
  print("x is greater than 5")
} else {
  print("x is less than or equal to 5")
}

# If-else if-else chain
score <- 75

if (score >= 90) {
  grade <- "A"
} else if (score >= 80) {
  grade <- "B"
} else if (score >= 70) {
  grade <- "C"
} else {
  grade <- "F"
}

grade
```

## Vectorized If-Else: ifelse()

The `ifelse()` function is vectorized, making it perfect for applying conditions to entire vectors:

```{r ifelse}
# Create a vector of test scores
scores <- c(92, 75, 88, 65, 95, 70)

# Assign grades using ifelse
grades <- ifelse(scores >= 80, "Pass", "Fail")
grades

# Nested ifelse for multiple conditions
detailed_grades <- ifelse(scores >= 90, "A",
                   ifelse(scores >= 80, "B",
                   ifelse(scores >= 70, "C", "F")))
detailed_grades
```

### Functions

Functions are reusable blocks of code that perform specific tasks. They are fundamental to writing clean, maintainable code.

### Creating Functions

```{r functions-basic}
# Basic function structure
square <- function(x) {
  result <- x^2
  return(result)
}

square(4)
square(1:5)
```

### Functions with Multiple Arguments

```{r functions-multiple-args}
# Function with default parameter values
power <- function(base, exponent = 2) {
  result <- base^exponent
  return(result)
}

power(3)      # Uses default exponent = 2
power(3, 3)   # Explicit exponent
power(2, exponent = 4)  # Named argument
```

### Practical Example: Statistical Summary Function

```{r functions-practical}
# Create a function that returns multiple statistics
summary_stats <- function(x, na.rm = TRUE) {
  list(
    mean = mean(x, na.rm = na.rm),
    median = median(x, na.rm = na.rm),
    sd = sd(x, na.rm = na.rm),
    min = min(x, na.rm = na.rm),
    max = max(x, na.rm = na.rm),
    n = length(x),
    n_missing = sum(is.na(x))
  )
}

# Test the function
test_data <- c(1, 2, 3, NA, 5, 6, 7, NA, 9, 10)
summary_stats(test_data)
```

## Loops and Iteration

### For Loops

For loops iterate over a sequence of values:

```{r loops-for}
# Basic for loop
for (i in 1:5) {
  print(paste("Iteration", i))
}

# Iterating over vector elements
fruits <- c("apple", "banana", "cherry")

for (fruit in fruits) {
  print(paste("I like", fruit))
}

# Building results in a loop
squares <- numeric(10)
for (i in 1:10) {
  squares[i] <- i^2
}
squares
```

### While Loops

While loops continue until a condition becomes FALSE:

```{r loops-while}
# Basic while loop
counter <- 1

while (counter <= 5) {
  print(paste("Counter is", counter))
  counter <- counter + 1
}

# Practical example: finding first value above threshold
x <- 1
while (2^x < 1000) {
  x <- x + 1
}
print(paste("2^", x, "=", 2^x, "is the first power of 2 above 1000"))
```

### Apply Family Functions

The apply family provides functional programming alternatives to loops. They are often faster and more concise.

### lapply: Apply Function to List/Vector

`lapply` always returns a list:

```{r lapply}
# Apply function to each element
numbers <- list(a = 1:5, b = 6:10, c = 11:15)

# Calculate mean of each element
lapply(numbers, mean)

# Using anonymous function
lapply(numbers, function(x) x^2)

# Practical example: read multiple files
# file_names <- c("data1.csv", "data2.csv", "data3.csv")
# data_list <- lapply(file_names, read.csv)
```

### sapply: Simplified Apply

`sapply` tries to simplify the result to a vector or matrix:

```{r sapply}
# Same operation, simplified output
sapply(numbers, mean)

# Returns vector instead of list
sapply(numbers, function(x) sum(x^2))

# When result can't be simplified, returns list like lapply
sapply(numbers, function(x) c(min = min(x), max = max(x)))
```

### vapply: Type-Safe Apply

`vapply` requires you to specify the output type, making it safer and sometimes faster:

```{r vapply}
# Specify output type
vapply(numbers, mean, FUN.VALUE = numeric(1))

# For multiple return values
vapply(numbers, function(x) c(mean = mean(x), sd = sd(x)),
       FUN.VALUE = numeric(2))

# Type safety prevents errors
# This would error if we tried to return character when numeric specified
```

## Comparison and Best Practices

```{r apply-comparison}
# Create example data
my_list <- list(
  group1 = rnorm(100, mean = 10, sd = 2),
  group2 = rnorm(100, mean = 15, sd = 3),
  group3 = rnorm(100, mean = 20, sd = 4)
)

# lapply: Always returns list
result_l <- lapply(my_list, summary)
class(result_l)

# sapply: Simplifies if possible
result_s <- sapply(my_list, mean)
class(result_s)

# vapply: Type-safe, better for production code
result_v <- vapply(my_list, mean, FUN.VALUE = numeric(1))
class(result_v)
```

**Best Practices:**
- Use `lapply` when you need a list output or when applying complex functions
- Use `sapply` for interactive analysis when you want simplified output
- Use `vapply` in production code or packages where type safety is important

## Practical Applications

### Example 1: Data Cleaning Pipeline

```{r practical-1}
# Create sample data with issues
messy_data <- data.frame(
  id = 1:6,
  value = c(10, 20, NA, 40, 50, 60),
  category = c("A", "B", "A", "C", "B", "A"),
  valid = c(TRUE, TRUE, FALSE, TRUE, TRUE, TRUE)
)

# Function to clean and summarize
clean_and_summarize <- function(df) {
  # Remove invalid rows
  df_clean <- df[df$valid == TRUE, ]

  # Remove missing values
  df_clean <- df_clean[!is.na(df_clean$value), ]

  # Calculate summary by category
  categories <- unique(df_clean$category)
  results <- lapply(categories, function(cat) {
    subset_data <- df_clean[df_clean$category == cat, "value"]
    c(
      category = cat,
      mean = mean(subset_data),
      n = length(subset_data)
    )
  })

  # Combine into data frame
  do.call(rbind, results)
}

clean_and_summarize(messy_data)
```

### Example 2: Simulation Study

```{r practical-2}
# Function to simulate and analyze data
simulate_experiment <- function(n_samples, effect_size) {
  # Generate data
  control <- rnorm(n_samples, mean = 100, sd = 15)
  treatment <- rnorm(n_samples, mean = 100 + effect_size, sd = 15)

  # Perform t-test
  test_result <- t.test(treatment, control)

  # Return key results
  list(
    effect_size = effect_size,
    p_value = test_result$p.value,
    significant = test_result$p.value < 0.05
  )
}

# Run simulations for different effect sizes
effect_sizes <- seq(0, 10, by = 2)
simulation_results <- lapply(effect_sizes, function(es) {
  simulate_experiment(n_samples = 50, effect_size = es)
})

# Convert to data frame for easy viewing
results_df <- do.call(rbind, lapply(simulation_results, as.data.frame))
results_df
```

## Summary

This tutorial covered essential advanced R programming concepts:

1. **Arrays**: Multidimensional data structures for complex data
2. **Lists**: Flexible containers for heterogeneous data
3. **Data Frames & Tibbles**: Core structures for statistical data analysis
4. **Data Types**: Understanding and working with different types
5. **Conditionals**: Making decisions in code with if-else and ifelse
6. **Functions**: Creating reusable, modular code
7. **Loops**: For and while loops for iteration
8. **Apply Functions**: Functional programming with lapply, sapply, and vapply

These tools form the foundation for efficient data analysis and statistical programming in R. Mastering them will enable you to write cleaner, more maintainable, and more efficient R code.

### Key Takeaways

- **Choose the right data structure**: vectors for homogeneous data, lists for heterogeneous, data frames for tabular data
- **Prefer vectorized operations** over loops when possible
- **Write functions** to avoid repeating code
- **Use apply functions** instead of for loops for cleaner functional code
- **Check and handle missing values** explicitly
- **Use type-safe functions** (like vapply) in production code

### Further Learning

To continue developing your R skills, explore:
- Advanced data manipulation with `dplyr` and `data.table`
- Functional programming with `purrr`
- Advanced visualization with `ggplot2`
- Writing efficient R code (vectorization, profiling)
- Creating R packages for reusable code
