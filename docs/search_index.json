[["index.html", "Object Naming and Types in R 1 Introducción", " Object Naming and Types in R Your Name 2026-01-14 1 Introducción These notes are designed for those who want to learn data analysis tools in R. They are structured as lecture-style class notes, which means they follow a sequential progression across sessions. Over time, these class notes have evolved—and they will continue to do so. They have been enriched thanks to contributions from several people. I am especially grateful to Camila Vivanco, Diego Menares, Catalina Buzio, Felix Ordoñez and Benjamín Pinto for their contributions. In addition, these notes are based on a variety of publicly available materials. Throughout the notes, I provide the corresponding bibliographic references and share free resources for readers who want to deepen or consolidate their knowledge. In many cases, examples have been adapted from these additional sources. I always make an effort to cite sources appropriately, with the goal of respecting original authorship and providing readers with access to valuable references. Please let me know if you find any errors. These notes have also been updated and adapted for the course ECON 326: Introduction to Econometrics II, an undergraduate course at the University of British Columbia (UBC), 2026. For suggestions, questions, or recommendations, feel free to contact me at ncamposbijit@gmail.com. "],["data-analysis-with-r.html", "2 Data Analysis with R ", " 2 Data Analysis with R "],["introduction-to-r-and-rstudio.html", "2.1 Introduction to R and RStudio", " 2.1 Introduction to R and RStudio This chapter introduces the basic workflow for working with R through RStudio. The goal is not only to learn commands, but also to develop good habits for writing clean, reproducible, and well-documented code. 2.1.1 Why use R? R is one of the most widely used programming languages for data analysis in Economics and the Social Sciences. Its main advantages are: Open source: R is free and has an active community that constantly develops new tools. Versatility: it supports statistical and econometric analysis, data cleaning, visualization, and automation (including tasks like web scraping). Reproducibility: scripts and reports allow you to document and replicate results reliably. Labor market value: open-source programming languages are increasingly demanded across research and industry. In this course we will treat R not as a “calculator”, but as a programming language: we will write code, create objects, use functions systematically, and build routines that scale to larger projects. 2.1.2 Key concepts (vocabulary of the course) Before writing code, it is important to define the core terms that will appear throughout the course: RStudio: a Graphical User Interface (GUI) designed to make working with R easier. Objects: anything you store in memory (datasets, variables, lists, plots, models, etc.). Functions: operations that take inputs and return outputs (e.g., mean(x), lm(y ~ x)). Packages: collections of functions grouped by purpose (e.g., dplyr, ggplot2, rio). Scripts / Code: files containing the commands that define your analysis pipeline. 2.1.3 Learning resources To learn R efficiently, you should rely on three types of resources: cheat sheets, forums, and structured books. Cheat sheets: short summaries of commands and workflows. Available at: https://www.rstudio.com/resources/cheatsheets/ Forums and websites: Stack Overflow: https://stackoverflow.com/questions/tagged/r Medium: https://preettheman.medium.com/awesome-tricks-every-r-coder-should-know-c4220cd2cfbc Posit Blog (formerly RStudio): https://posit.co/ Books: R for Data Science: https://r4ds.had.co.nz/ Posit resources in Spanish: https://posit.co/resources/videos/ Bookdown: https://bookdown.org/ 2.1.4 RStudio interface RStudio is a convenient “vehicle” for working with R. The interface usually displays four main panels, which help you organize your work: Scripts (Source): where you write and save code. Console: where R runs commands and prints results. Environment / History: where you see the objects created in memory. Files / Plots / Packages / Help: tools to navigate folders, view plots, manage packages, and read documentation. A key takeaway is that most of your work should live in the Script, not in the Console. The Console is useful for quick checks, but scripts are what ensure reproducibility. You can customize RStudio via: Tools → Global Options (font size, theme, layout, etc.). The purpose is to make your workflow as intuitive and efficient as possible. "],["writing-code-comments-structure-and-cleaning-the-environment.html", "2.2 Writing code: comments, structure and cleaning the environment", " 2.2 Writing code: comments, structure and cleaning the environment 2.2.1 Comments Good code is code that other people (including “future you”) can understand. Comments are essential to explain why you do something, not only what you do. To write comments in R scripts, use #. To comment multiple lines at once use: Ctrl + Shift + C (Windows) Cmd + Shift + C (Mac) A very useful reference for best practices is: Code and Data for the Social Sciences: A Practitioner’s Guide 2.2.2 Outlines (code indexing) RStudio allows you to structure scripts using headings. This creates an outline that helps navigation in long files. Open outline: Ctrl + Shift + O Headings can be hierarchical: # The most important ## This is a bit less important ### This is a bit less important than the previous one #### The least important Keeping the outline updated is not optional: as the script grows, the outline becomes one of the main tools to navigate your code efficiently. If headings are outdated or inconsistent, the outline loses its usefulness and long scripts become harder to maintain. 2.2.3 Cleaning in R: environment vs console When working in R, it is important to distinguish between two different things: The environment (memory): where R stores the objects you create (datasets, vectors, models, plots, etc.). The console (screen): where commands and results are printed. Cleaning the environment is about deleting objects stored in memory. Cleaning the console is only about making the screen look “clean” — it does not delete anything. Remove all objects from the environment rm(list = ls()) Remove only one object # rm(data1) "],["package-installation-libraries-and-help.html", "2.3 Package installation, libraries and help", " 2.3 Package installation, libraries and help In R, most of the tools we use are contained in packages. A package is simply a collection of functions designed for a specific purpose (e.g., data cleaning, plotting, importing files, estimation). A key distinction is the following: Packages are installed once on your computer. Packages must be loaded every time you open a new R session in order to use them. This difference is crucial: many beginner errors come from confusing “installing” with “loading”. 2.3.1 Libraries There are two standard ways to install packages in RStudio: Using the Packages tab in the bottom-right panel. Using commands directly in R. install.packages(&quot;dplyr&quot;) Many packages at the same time: install.packages(c(&quot;dplyr&quot;,&quot;ggplot2&quot;,&quot;rio&quot;)) Common error: install.packages(dplyr, &quot;ggplot2&quot;) In general, it is a good idea to install them at the beginning of your work, since we commonly use the same libraries when doing data analysis. With this function, we tell R to install the package if it is not installed (something typical when we switch computers): if(!require(dplyr)) {install.packages(&quot;dplyr&quot;)} Load libraries: library(dplyr) If we want to see what is inside each package: ls(&quot;package:dplyr&quot;, all = TRUE) #ls = list objects Important: the package must be installed once, but loaded every time it is used. There are often updates. To check and install them: update.packages() Alternatively, I can link a package to a function using ::. If I do this, it is not necessary to load the library in order to use that specific function. However, the recommended practice is to load all the libraries of the packages I will use at the beginning. 2.3.2 Help function About a specific function: help(mean) ?mean mean sd About a specific package: help(&quot;dplyr&quot;) library(help=&quot;dplyr&quot;) 2.3.3 Useful Shortcuts Esc: interrupt the current command Ctrl + s: save tab: autocomplete Ctrl + Enter: run line Ctrl + Shift + C: comment/uncomment &lt;-: Alt + - / option + - %&gt;%: Ctrl + Shift + M (pipe) Ctrl + l: clear console Ctrl + Alt + b: run everything up to here (the arrow keys in the console allow you to view the most recent commands used) Shift + lines: select multiple lines Ctrl + f: find/replace Ctrl + Up Arrow (in the console): view previously used commands 2.3.3.1 Identify the package of a function Sometimes we want to know which package a given function belongs to. For that, check: https://sebastiansauer.github.io/finds_funs/ ` Note that a + sign appears in the console. In these cases, RStudio stops because you probably forgot a ) or a #. You must correct the error, run the code again, and then press Esc in the console to continue executing commands. "],["r-markdown---reproducible-research.html", "2.4 R Markdown - Reproducible research", " 2.4 R Markdown - Reproducible research R Markdown is one of the most useful tools in applied data analysis because it allows you to combine explanatory text with executable code in a single document. The key idea is simple: You write the analysis once, and every time the data changes, you can re-run the document to automatically update tables, figures, and results. This makes your work: Automatic: outputs are generated by code (not manually copied). Reproducible: anyone can re-run the document and obtain the same results. Well documented: results are always accompanied by explanations, interpretation, and methodology. In practice, an R Markdown file (.Rmd) works like a hybrid between a report and a script: it contains written text (like a Word document) and chunks of code (like an R script). When you compile (“knit”) the file, R executes the code chunks and inserts the results (tables, plots, numbers) directly into the final report. 2.4.1 What can R Markdown produce? An .Rmd file can generate many different types of outputs, such as: Word reports (.docx) PDF reports (.pdf) HTML reports (.html) Presentations (slides) Dashboards (interactive documents) More importantly, an .Rmd file can include all elements that typically appear in a data analysis: plain text explanations R code chunks tables plots regression output automatically updated statistics (means, SDs, p-values, etc.) 2.4.2 When is R Markdown especially useful? R Markdown is particularly valuable in two common situations: Routine reports Example: a weekly report with updated descriptive statistics and graphs. Instead of rewriting the report every week, you update the data and re-knit. Reports for subsets of a dataset Example: a dataset contains several countries. You want one report per country. With R Markdown, you can parameterize the report and automatically generate one output per country. The general lesson is: if you are repeating work manually, it can probably be automated with R Markdown. "],["basic-concepts.html", "2.5 Basic concepts", " 2.5 Basic concepts To understand R Markdown, you need to distinguish the following components: 2.5.1 Markdown (.md) Markdown is a simple plain-text language to format documents. For example: # Title creates a section title **bold** produces bold text lists, links, and images are easy to write Markdown files have extension .md. 2.5.2 R Markdown (.Rmd) R Markdown extends Markdown by allowing you to embed R code directly into the document. Files have extension .Rmd. The most important feature is that R code is executed and its output is included in the report. This is what makes the document dynamic and reproducible. 2.5.3 knitr knitr is the R package responsible for: reading the .Rmd file identifying code chunks executing the R code inserting the results (tables/figures/output) into the document In other words: knitr is the engine that turns the .Rmd file into a report. 2.5.4 Pandoc Pandoc is the tool that converts the report into a final format such as PDF, Word, or HTML. It takes the document produced by knitr and transforms it into a clean formatted file. Pandoc is installed automatically with RStudio, so you do not need to install it manually. 2.5.5 Process (how everything works together) The workflow is: You write text and R code in a single .Rmd document. knitr executes the code chunks. Pandoc converts the final output into PDF/Word/HTML. Source: https://rmarkdown.rstudio.com/authoring/quick_tour.html 2.5.6 Your first R Markdown file To create your first .Rmd document in RStudio: Go to: File → New File → R Markdown Choose the output format: report / presentation / dashboard Set the document title and author The most common starting point is a simple report that outputs to HTML or Word. 2.5.7 Working directory (critical detail) A frequent source of confusion in R Markdown is the working directory. The general rule is: The working directory of an .Rmd file is the folder where the .Rmd file is saved. This means that if your .Rmd file is saved in a folder, R will look for datasets and external files in the same folder (unless you specify full paths). For this course, we will keep things simple: - store your data in the same folder as the .Rmd file - avoid complicated paths until you gain familiarity This is a best practice for beginners because it reduces file-loading errors. 2.5.8 Components of an R Markdown file An R Markdown file has three main components: YAML header A block at the top of the file containing metadata (title, author, output type). Markdown text Where you write narrative explanations: motivation, steps, interpretation. Code chunks Blocks of R code used for loading packages, importing data, transforming variables, estimating models, and generating plots. A code chunk looks like this: A typical workflow is: YAML sets format + structure Markdown text explains what you are doing code chunks do the analysis and generate outputs 2.5.9 Why is this powerful? In Word/Excel workflows, people often: - run regressions in one place, - copy results into a document, - manually update tables and plots. This is slow and error-prone. With R Markdown: - your report is generated directly from code, - results are always consistent with data, - there is no manual copy/paste. That is why R Markdown is considered a core tool for reproducible research. ### Working directory The working directory of a .Rmd file is the folder where the file is saved. Therefore, R will search for files in the same folder where the .Rmd file is stored. For this exercise, we will simply keep the data we use in the same folder as the .Rmd file. 2.5.10 Components of R Markdown YAML: set title, date, and output type. Markdown text: write narrative text. Code chunk: load packages, data, and create visualizations. "],["object-manipulation.html", "2.6 Object manipulation", " 2.6 Object manipulation 2.6.0.1 Using R as a calculator / running commands You can run commands in R in an interactive way, just like using a calculator. To do this, select the line(s) of code you want to execute and press: Ctrl + Enter (Windows) Cmd + Enter (Mac) This allows you to run commands separately (one line at a time or a selected block), without executing the entire script. 2+2 ## [1] 4 3*5^(1/2) ## [1] 6.708204 2.6.0.2 Running all instructions To execute the entire script (i.e., run all commands in the file at once), you have several options: Click Source (top-right of the Script panel) to run the whole script. Use the menu: Code → Run Region → Run All. Shortcut: Ctrl + Alt + R (Windows) / Cmd + Option + R (Mac) Running the full script is useful when you want to reproduce the complete workflow from start to finish (e.g., cleaning data, generating tables, producing plots). 2+2 ; 3*5^(1/2) ## [1] 4 ## [1] 6.708204 3+4 ## [1] 7 5*4 ## [1] 20 8/4 ## [1] 2 6^7 ## [1] 279936 6^77 ## [1] 8.272681e+59 log(10) ## [1] 2.302585 log(1) ## [1] 0 sqrt(91) # raiz cuadrada ## [1] 9.539392 round(7.3) # redondear ## [1] 7 Even large operations can be executed this way. For example, you can select and run a full block of code (data imports, transformations, loops, regressions, plots) instead of running commands one by one. This is especially useful when your analysis requires multiple steps that must be executed in the correct order. sqrt(91) + 4892788*673 - (log(4)*round(67893.9181, digits = 2)) ## [1] 3292752213 You can even work with complex numbers (imaginary numbers) in R. In R, the imaginary unit is written as i, and complex numbers can be used in arithmetic operations just like real numbers. Example: 2i+5i+sqrt(25i) ## [1] 3.53553+10.53553i 2.6.0.3 Object creation: assignment and functions In R, we create objects using the assignment operator &lt;-. This is one of the most important operations in the language, because almost everything we do in R consists of creating and transforming objects (vectors, datasets, models, plots, etc.). It is also possible to assign values using =, but this is not recommended in general practice, since it can be confusing (especially inside functions). The recommended standard in most applied work is to use &lt;-. y &lt;- 2 + 4 y ## [1] 6 "],["understanding-assignments-and-functions-in-r.html", "2.7 Understanding Assignments and Functions in R", " 2.7 Understanding Assignments and Functions in R Assignments in R are silent operations. When we create an assignment, it stores the value but does not automatically display it in the console. To see the result of an assignment, we must explicitly call the object by typing its name or using the print() function. While simple assignments are straightforward, the real power of R lies in generating assignments through functions. Functions are the central component of working with R. Some functions come pre-installed with the base R installation, while others must be obtained from external packages. Additionally, users can write their own custom functions. Functions are typically written with parentheses, such as filter(). In some cases, functions are associated with specific packages and are referenced using the double colon notation, for example dplyr::filter(). Let’s explore how functions work through several examples. First, we can apply a simple mathematical function: sqrt(49) ## [1] 7 This calculates the square root of 49. We can also apply functions to datasets. For instance, we can obtain summary statistics for a variable within a dataset: summary(mtcars$mpg) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 10.40 15.43 19.20 20.09 22.80 33.90 The mtcars dataset comes pre-installed with R and contains information about various car models. To see other datasets that come bundled with R, we can use the data() function: data() 2.7.1 Working with Vectors and Arithmetic Functions We can create objects by assigning values to them and then combine these objects into vectors. A vector is a fundamental data structure in R that contains elements of the same type: x &lt;- 2 y &lt;- 3 z &lt;- c(x, y) z ## [1] 2 3 Here, we create two individual numeric objects (x and y) and then combine them into a vector z using the concatenate function c(). Once we have a vector, we can apply various statistical functions to it: mean(z) ## [1] 2.5 median(z) ## [1] 2.5 These functions calculate the arithmetic mean and median of the values in the vector, respectively. 2.7.2 Creating Relationships Between Objects We can create new objects based on calculations performed on existing objects. For example, we can store the mean of a vector as a new object: w &lt;- mean(z) We can also create objects through arithmetic operations: a &lt;- 3 + 10 b &lt;- 2 * 4 R allows us to perform logical comparisons between objects: a &gt; b ## [1] TRUE This returns a logical value (TRUE or FALSE) indicating whether a is greater than b. 2.7.3 The Silent Nature of Assignments As mentioned earlier, assignments do not produce output unless we explicitly request it. To display the contents of an object, we simply type its name or use the print() function: a ## [1] 13 b ## [1] 8 # alternatively, use print print(a) ## [1] 13 print(b) ## [1] 8 2.7.4 Building Complex Objects from Functions We can build more complex objects by combining multiple operations. For instance, we can create a vector from previously defined objects and calculate its mean: valores &lt;- c(a, b) promedio &lt;- mean(valores) print(promedio) ## [1] 10.5 promedio ## [1] 10.5 Let’s work through another example where we calculate the mean of two values: a &lt;- 2 b &lt;- 5 valores1 &lt;- c(a, b) promedio1 &lt;- mean(valores1) print(promedio1) ## [1] 3.5 To clear our workspace and remove specific objects, we can use the rm() function: rm(list = ls()) rm(promedio) The first command removes all objects from the environment, while the second removes a specific object. 2.7.5 Working with Real Data: Education and Income Example Proper spacing and organization of code is essential for readability and maintenance. Let’s create two vectors representing education (in years) and income for ten individuals using the concatenate function c(): educ &lt;- c(8, 12, 8, 11, 16, 14, 8, 10, 14, 12) ingreso &lt;- c(325, 415, 360, 380, 670, 545, 350, 420, 680, 465) Once we have these vectors, we can calculate various descriptive statistics. We can compute the mean income, the standard deviation of income, and the correlation between education and income: mean(ingreso) ## [1] 461 promedioingreso &lt;- mean(ingreso) sd(ingreso) ## [1] 129.1382 sdingreso &lt;- sd(ingreso) cor(educ, ingreso) ## [1] 0.9110521 coreduing &lt;- cor(educ, ingreso) The mean provides the average income, the standard deviation measures the dispersion of income values around the mean, and the correlation coefficient quantifies the strength and direction of the linear relationship between education and income. 2.7.6 Visualizing the Relationship To visually examine the relationship between education and income, we can create a scatter plot: plot(educ, ingreso) This produces a graph with education on the x-axis and income on the y-axis, allowing us to see the pattern of association between these two variables. 2.7.7 Estimating a Linear Regression Model Finally, we can formally model the relationship between education and income using linear regression. The lm() function estimates a linear model where income is the dependent variable and education is the independent variable: lm(ingreso ~ educ) ## ## Call: ## lm(formula = ingreso ~ educ) ## ## Coefficients: ## (Intercept) educ ## -8.71 41.57 This function returns the estimated coefficients for the linear model, providing us with the intercept and the slope coefficient for education. The slope coefficient indicates how much income is expected to change for each additional year of education. "],["object-naming-and-types.html", "2.8 Object Naming and Types", " 2.8 Object Naming and Types 2.8.1 Naming Objects The following exercise helps us understand the rules for valid variable names in R. Exercise: Valid Variable Names Consider the following examples. Which of these are valid variable names in R? # min_height # Valid: uses underscore # max.height # Valid: uses dot # _age # Invalid: starts with underscore # .mass # Valid: starts with dot (but creates hidden variable) # MaxLength # Valid: uses camel case # Min-length # Invalid: uses hyphen (minus sign) # 2widths # Invalid: starts with number # Calsius2kelvin # Valid: number in middle is allowed In R, variable names must follow these rules: they can contain letters, numbers, dots, and underscores, but they must start with a letter or a dot (if starting with a dot, the second character cannot be a number). Variable names cannot contain spaces or special characters like hyphens, and they cannot start with numbers or underscores. 2.8.2 Types of Objects 2.8.2.1 Vectors R operates component by component, which makes it very straightforward to work with vectors and matrices. Vectors are one-dimensional arrays that can hold numeric data, character data, or logical data, but all elements must be of the same type. To create a vector, we use the c() function (which stands for “concatenate” or “combine”): x &lt;- c(1, 2, 3, 4, 5) # or alternatively y &lt;- c(6:8) Let’s examine what happens when we add vectors together: z &lt;- x + y z ## [1] 7 9 11 10 12 Now, let’s consider two vectors of different lengths: x &lt;- c(1:4) y &lt;- c(1:3) We can check the length of each vector using the length() function: length(x) ## [1] 4 length(y) ## [1] 3 What happens when we try to add vectors of different lengths? z &lt;- x + y z ## [1] 2 4 6 5 IMPORTANT: In this case, R performs the operation anyway, but it gives us a warning that the lengths differ. R uses “vector recycling,” where the shorter vector is repeated to match the length of the longer vector. A crucial characteristic of vectors is that they can only concatenate elements of the same type; otherwise, R will coerce all elements to a common type (usually character if there’s a mix). Let’s explore more vector operations: x &lt;- rep(1.5:9.5, 4) # generates repetitions of the defined values y &lt;- c(20:30) x1 &lt;- c(1, 2) x2 &lt;- c(3, 4) x3 &lt;- c(x1, x2) x4 &lt;- c(c(1, 2), c(3, 4)) 2.8.2.1.1 Subsetting Vectors We can extract specific elements from a vector using square bracket notation: y[3] # get the third element ## [1] 22 y[2:4] # get elements 2 through 4 ## [1] 21 22 23 y[4:2] # get elements in reverse order (4, 3, 2) ## [1] 23 22 21 y[c(2, 6)] # get elements 2 and 6 ## [1] 21 25 y[c(2, 16)] # attempt to get element 16 (returns NA if out of bounds) ## [1] 21 NA 2.8.2.2 Matrices Matrices are two-dimensional arrays where all elements must be of the same type. They are particularly useful for mathematical operations and organizing data in rows and columns. 2.8.2.2.1 Defining Matrices The general syntax for creating a matrix is: my.matrix &lt;- matrix(vector, ncol = num_columns, nrow = num_rows, byrow = logical_value, dimnames = list(vector_row_names, vector_column_names)) To create matrices, we use the matrix() function: x &lt;- matrix(data = c(1, 2, 3, 4), nrow = 2, ncol = 2) x1 &lt;- matrix(c(1, 2, 3, 4), 2, 2) While it is not necessary to explicitly write data=, doing so improves code readability and makes the intent clearer. x ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 x1 ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 Note that by DEFAULT, R fills the matrix column by column. We can explicitly specify that we want to fill the matrix row by row using the byrow argument: y &lt;- matrix(data = c(1:4), nrow = 3, ncol = 2, byrow = TRUE) y ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 1 2 We can determine the dimensions of a matrix using the dim() function: dim(y) ## [1] 3 2 dim(y)[1] # number of rows ## [1] 3 dim(y)[2] # number of columns ## [1] 2 y &lt;- matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2, byrow = 2) y ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 If the vector is shorter than the matrix dimensions, R will recycle the values to fill the matrix: y &lt;- matrix(c(1, 2, 3, 4), nrow = 2, ncol = 3, byrow = 2) y ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 1 2 Note that the order in any matrix is always rows × columns. We can also omit either the number of rows or columns, and R will calculate the missing dimension: y &lt;- matrix(c(1:4), 2, byrow = T) y ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 When creating empty matrices, we must define the dimensions: y &lt;- matrix(nrow = 3, ncol = 3) y # useful for loops where we fill values iteratively ## [,1] [,2] [,3] ## [1,] NA NA NA ## [2,] NA NA NA ## [3,] NA NA NA 2.8.2.2.2 Naming Rows and Columns We can assign names to rows and columns directly in the matrix() function: y &lt;- matrix(c(1:4), 2, byrow = FALSE, dimnames = list(c(&quot;X1&quot;, &quot;X2&quot;), c(&quot;Y1&quot;, &quot;Y2&quot;))) y ## Y1 Y2 ## X1 1 3 ## X2 2 4 Alternatively, we can use the colnames() and rownames() functions: colnames(x) &lt;- c(&quot;Variable 1&quot;, &quot;Variable 2&quot;) rownames(x) &lt;- c(&quot;a1&quot;, &quot;a2&quot;) x ## Variable 1 Variable 2 ## a1 1 3 ## a2 2 4 2.8.2.2.3 Adding Rows or Columns to a Matrix Let’s create a new vector to add to our matrix: w &lt;- c(5, 6) We can combine matrices and vectors using rows (note that the vector name becomes the row name): z &lt;- rbind(x, w) z ## Variable 1 Variable 2 ## a1 1 3 ## a2 2 4 ## w 5 6 We can also combine using columns: z &lt;- cbind(x, w) z ## Variable 1 Variable 2 w ## a1 1 3 5 ## a2 2 4 6 What happens if they have different numbers of rows and/or columns? R will recycle the shorter vector or observation to match the longer dimension: x &lt;- matrix(c(1:9), 3) x ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 y &lt;- c(5, 6) y ## [1] 5 6 z &lt;- rbind(x, y) z ## [,1] [,2] [,3] ## 1 4 7 ## 2 5 8 ## 3 6 9 ## y 5 6 5 2.8.2.2.4 Converting Vectors to Matrices We can convert a vector to a matrix by assigning dimensions: x &lt;- 1:10 x ## [1] 1 2 3 4 5 6 7 8 9 10 dim(x) &lt;- c(2, 5) x ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 2.8.2.2.5 Transposing Matrices We can transpose a matrix (swap rows and columns) using the t() function: x &lt;- matrix(c(1:9), 3) x_transposed &lt;- t(x) x_transposed ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 2.8.2.2.6 Subsetting Matrices We can extract specific elements, rows, or columns from a matrix. For example, to get the second and fourth elements of the second row: M &lt;- matrix(1:8, nrow = 2) M ## [,1] [,2] [,3] [,4] ## [1,] 1 3 5 7 ## [2,] 2 4 6 8 M[1, 1] # element in first row, first column ## [1] 1 M[1, ] # entire first row ## [1] 1 3 5 7 M[, 2] # entire second column ## [1] 3 4 M[2, c(2, 4)] # second and fourth elements of the second row ## [1] 4 8 Matrix subsetting uses the format [row, column], where leaving either position blank returns all rows or all columns, respectively. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
