# Data Analysis with R

## Introduction to R and RStudio

### Why use R as a programming language?

-  **Open source:** The license is free.

-  **Versatile:** statistical and econometric analysis + useful programming tasks (e.g., web scraping).

-  **Flexible and reproducible:** ensures reproducibility, is flexible to changes and error detection. 
    
-  **In demand:** Open-source programming languages are increasingly requested in the labor market.

### Key and recurring terms throughout the course

-   **RStudio:** Graphical User Interface. It is designed to make using R easier.
-   **Objects:** Anything you store in R. For example: datasets, variables, lists of names, plots.
-   **Functions:** An operation produced by code that accepts inputs and returns outputs.
-   **Packages:** A set of functions grouped according to their purpose. 
-   **Scripts/Code:** Document that contains all commands used in a data analysis process.

### Learning Resources

::: {style="text-align: justify"}
-   Cheat sheets: material available with a summary of the main commands/packages/functions for different topics.
    Available at: <https://www.rstudio.com/resources/cheatsheets/>
:::

-   Forums and websites:
    -   [Stackoverflow](https://stackoverflow.com/questions/tagged/r)
    -   [Medium](https://preettheman.medium.com/awesome-tricks-every-r-coder-should-know-c4220cd2cfbc)
    -   [The RStudio Blog](https://posit.co/)
-   Books:
    -   [R for Data Science](https://r4ds.had.co.nz/)
    -   [Resources about R in Spanish.](https://posit.co/resources/videos/)
    -   [Bookdown](https://bookdown.org/)
- 

### RStudio Interface

#### Four sections in RStudio

The fundamental ones are: *Scripts, Console, 
Environment/Files/Help*.

- **Scripts:** Where we will develop the code. It is a notebook. 
- **Console:** Where we will see the results.
- **Environment:** Where we will see the data and the information we are generating.
- **Files:** Where we will see the files associated with our projects.
- **Help:** Where we will develop the code. It is a notebook. 

To customize RStudio go to: **Tools -> Global Options**.
There you can change the environment color, font type, layout order. The
idea is to use RStudio in the most intuitive way possible. 

#### Writing comments

It is very important to write comments throughout your code. It is also important to know how to write **good** comments. A very good guide that discusses this and many other things is: [Code and Data for the Social Sciences: A Practitioner's Guide](https://web.stanford.edu/~gentzkow/research/CodeAndData.pdf).

`(#)` to write comments in the script. If I want to mark multiple
lines as comments: `ctrl + shift + c`

#### Indices

It is important to write indices to document your code. To
see it I must type: `ctrl + shift + o`

Titles can be hierarchical:

```{r message=FALSE}
# The most important
## This is a bit less important
### This is a bit less important than the previous one
#### The least important
```

Es importante actualizarlo constantemente para no perder funcionalidad.

### Instalación de paquetes y ayuda

Los paquetes son basicamente conjuntos de funciones. Los paquetes se
instalan una vez, pero se llaman siempre que se vayan a utilizar.

#### Librerías

Esto se puede hacer de dos maneras:

1.  Desde la pestaña *packages* en la esquina inferior derecha.

2.  Con comandos

```{r message = FALSE, warning = FALSE, results="hide"}
install.packages("dplyr")
```

Varios paquetes a la vez:

```{r, eval=FALSE}
install.packages(c("dplyr","ggplot2","rio"))
```

Error común:
```{r, eval=FALSE}
install.packages("dplyr", "ggplot2")
```

Por lo general es bueno instalarlas desde el inicio del trabajo dado que
comúnmente usamos las mismas librerías al realizar análisis de datos.
Con esta función le decimos a R que instale el paquete si este no está
instalado (algo típico cuando cambiamos de computador):

```{r, eval=FALSE}
if(!require(dplyr)) {install.packages("dplyr")}
```

Cargar librerías:

```{r, eval=FALSE}
library(dplyr)
```

Si queremos ver que hay dentro de cada paquete:

```{r, eval=FALSE}
ls("package:dplyr", all = TRUE) #ls = list objects
```

**Importante**: el paquete debe ser instalado una vez, pero cargado cada
vez que se utilice. Muchas veces hay actualizaciones. Para revisar e
instalarlas.

```{r, eval=FALSE}
update.packages()
```

Alternativamente puedo conectar paquete con función utilizando `::`. Si
hago esto no es necesario llamar a la librería para utilizar esa función
en particular. No obstante, lo recomendable es cargar todas las
librerías de los paquetes que voy a utilizar al inicio.

#### Función de ayuda

Sobre una función en particular:

```{r, eval=FALSE}
help(mean) 
?mean 
mean #pulsar la tecla F1 
sd
```

Sobre un paquete en particular:

```{r, eval=FALSE}
help("dplyr") 
library(help="dplyr")
```

#### *Shortcuts* útiles

-   `Esc`: interrumpir el comando actual
-   `Ctrl + s`: guardar
-   `tab`: autocompletar
-   `Ctrl + Enter`: ejecutar línea
-   `Ctrl + Shift + C`: comentar
-   `<-`: Alt + - / option + -
-   `%>%`: ctrl + shift + m (*pipe*)
-   `Ctrl + l`: limpiar
-   `Ctrl + alt + b`: ejecutar todo hasta aquí (flechas en la consola me
    permiten ver los últimos comandos utilizados).
-   `Shift + lineas`: seleccionar varias lineas
-   `Ctrl + f`: buscar/remplazar
-   `Ctrl + "flecha arriba" en la consola`: ver comandos utilizados.

#### Limpiar *"environment"* en R

Eliminar todos los objetos:

```{r}
rm(list=ls())
```

Eliminar sólo un objeto:

```{r}
rm(data1)
```

Si quiero limpiar la consola tengo que apretar `Ctrl + L`.

#### Identificar el paquete de una función

Hay ocasiones en que queremos saber de que paquete es una función
determinada. Para ello, revisar:
<https://sebastiansauer.github.io/finds_funs/>

#### Error común

Por ejemplo:

```{r}
x <- "hola"
```

Noten que en la consola aparece un signo `+`. En estos casos RStudio se
detiene porque probablemente se les olvido un `)` o bien un `#`. En
estos casos hay que corregir el error para ejecutar nuevamente y luego
apretar `esc` en la consola para seguir ejecutando los comandos.

### Manipulación de objetos

#### Usar R como calculadora/ejecutar comandos

De manera separada (seleccionar las `ordenes+ctrl+Enter`):

```{r}
2+2 
3*5^(1/2)
```

Ejecutar todas las instrucciones:

```{r}
2+2 ; 3*5^(1/2)
3+4 
5*4 
8/4 
6^7
6^77

log(10) 
log(1)

sqrt(91) # raiz cuadrada

round(7.3) # redondear
```

Incluso grandes operaciones:

```{r}
sqrt(91) + 4892788*673 - (log(4)*round(67893.9181, digits = 2))
```

Incluso uso de números imaginarios:

```{r}
2i+5i+sqrt(25i)
```

#### Creacion de objetos: asignaciones y funciones

con el signo `<-` asignamos valores. También se puede utilizar `=`, pero
no es recomendable, ya que confunde.

```{r}
y <- 2 + 4 
y
```

Las asignaciones son MUDAS. Si no las llamo, no aparecen en la consola.
Lo anterior es una operación sencilla, pero lo que queremos es generar
asignaciones con funciones.

Podemos utilizar funciones. Las funciones son la parte central del uso
de R. Algunas funciones vienen instaladas en R. Otras funciones hay que
obtenerlas desde paquetes. También es posible escribir tus propias
funciones `()`. Las funciones estan por lo general escritas en
paréntesis, por ejemplo `filter()`. Hay ocasiones en que las funciones
estan relacionadas con un paquete específico `dplyr::filter()`.

-   Ejemplo 1: función simple

```{r}
sqrt(49)
```

-   Ejemplo 2: sobre una base de datos

```{r}
summary(mtcars$mpg)
```

*Nota:* mtcars viene incluidad en R.

Para ver mas:

```{r}
data()
```

Otra función:

```{r}
x <- 2 
y <- 3
z <-c(x,y) 
z
```

Uso de funciones aritméticas:

```{r}
mean(z) 
median(z)
```

Relaciones entre objetos:

```{r}
w <- mean(z)
```

Creación de objetos por asignación:

```{r}
a <- 3+10 
b <- 2*4
```

Comparar objetos:

```{r}
a > b
```

Notar que las asignaciones son silenciosas:

```{r}
a 
b 
# o altenativamente utilizar print 
print(a) 
print(b)
```

Creación de objetos usando funciones:

```{r}
valores <- c(a,b)
promedio <- mean(valores)
print(promedio)
promedio
```

Podemos escribir un promedio aquí usando función `mean():`

```{r}
a <- 2 
b <- 5
valores1 <- c(a,b)
promedio1 <-mean(valores1)
print(promedio1)
```

Limpiamos datos nuevamente:

```{r}
rm(list = ls()) 
rm(promedio)
```

#### Creacion de objetos y asignaciones

Es importante espaciar codigos. Definimos dos vectores utilizando la
función `c()`

```{r}
educ <- c(8,12,8,11,16,14,8,10,14,12)
ingreso <- c(325,415,360,380,670,545,350,420,680,465)
```

Calculamos promedio, desviación estándar y correlación

```{r}
mean(ingreso)
promedioingreso <- mean(ingreso)

sd(ingreso)
sdingreso <- sd(ingreso)

cor(educ, ingreso)
coreduing <- cor(educ,ingreso)
```

Graficamos

```{r}
plot(educ, ingreso)
```

Estimar una regresión lineal

```{r}
lm(ingreso ~ educ)
```

::: {.alert .alert-block .alert-warning}
<b>Ejercicio 2.1.1:</b> Nombrar objetos

De los siguientes ejemplos, ¿Cuáles son nombres de variables válidas en
R?

```{r}
# min_height
# max.height
# _age
# .mass
# MaxLength
# Min-length
# 2widths
# Calsius2kelvin
```
:::

### Tipos de objetos

#### Vectores

R opera componente por componente, por lo que es muy sencillo poder
trabajar con vectores y matrices.

Para crear un vector utilizamos la funcion `c()`

```{r}
x <- c(1,2,3,4,5)
#o bien
y <- c(6:8)
```

Veamos los vectores

```{r}
z <- x + y 
z
```

Supongamos los siguientes vectores:

```{r}
x<-c(1:4)
y<-c(1:3)
```

¿Cuál es su longitud?

```{r}
length(x)
length(y)
```

Si no tienen la misma longitud, ¿cual sería el resultado de `x + y`?

```{r}
z <- x + y 
z
```

**IMPORTANTE**: En este caso R realiza la operación de todos modos, pero
nos indica que hay una advertencia de que sus dimensiones difieren. Lo
relevante de los vectores es que sólo se puede concatenar elementos del
mismo tipo, de lo contrario R nos arroja error.

```{r}
x <- rep(1.5:9.5,4) #genera repeticiones de los valores definidos 
y <- c(20:30)
x1 <- c(1,2)
x2 <- c(3,4)
x3 <- c(x1,x2)
x4 <- c(c(1,2), c(3,4))
```

Subconjunto de un vector

```{r}
y[3] # obtener el tercer elemento 
y[2:4] 
y[4:2]
y[c(2,6)]
y[c(2,16)]
```

#### Matrices

##### Definir matrices

Sintaxis general

```{r, eval=FALSE}
mi.matriz <- matrix(vector,
                    ncol = num_columnas, 
                    nrow = num_filas,
                    byrow = valor_logico,
                    dimnames = list(vector_nombres_filas,
                                   vector_nombres_columnas)
)

```

Para crear matrices utilizamos la función `matrix()`

```{r}
x <- matrix (data = c(1,2,3,4), 
             nrow = 2, 
             ncol = 2) 


x1 <- matrix(c(1,2,3,4), 
             2, 
             2)
```

No es necesario poner `data=`, pero por orden mental es mejor hacerlo.

```{r}
x 
x1
```

Notar que por DEFECTO rellena columna por columna. Podemos explicitar
que queremos realizar la matriz fila por fila

```{r}
y <- matrix(data = c(1:4),
          nrow = 3, 
          ncol = 2, 
          byrow = TRUE)
y
```

Podemos saber cual es la dimensión de `x`

```{r}
dim(y)
dim(y)[1] # cantidad de filas
dim(y)[2] # cantidad de columnas

y<- matrix(c(1,2,3,4), nrow=2, ncol=2, byrow=2)
y
```

Los va a repetir!

```{r}
y <- matrix(c(1,2,3,4), nrow=2, ncol=3, byrow= 2) 
y
```

Notar que el orden en cualquier matrix es **filas x columnas**. Podemos
también omitir la cantidad de filas o columnas en la matriz y obtenemos
el mismo resultado

```{r}
y <- matrix(c(1:4), 2, byrow=T)
y 
```

En el caso de crear matrices vacías hay que definir las dimensiones

```{r}
y <- matrix(nrow=3, ncol=3)
y #útil para los loops
```

Darle nombre a las filas y columnas

```{r}
y <- matrix (c(1:4), 2, byrow = FALSE, 
             dimnames=list(c("X1","X2"),c("Y1", "Y2")))
y
```

Se puede realizar desde las funciones colnames y rownames

```{r}
colnames(x) <- c("Variable 1", "Variable 2")
rownames(x) <- c("a1", "a2")
x
```

Añadir filas o columnas a una matriz

```{r}
w <- c(5,6)
```

##### Unir matrices

Unir mediante filas (queda con el nombre del vector la observación)

```{r}
z <- rbind(x,w) 
z
```

Unir mediante columnas

```{r}
z <- cbind(x,w) 
z
```

¿Y si tienen diferente cantidad de filas y/o columnas? repite el vector
o observaci?n con menor longitud

```{r}
x <- matrix(c(1:9),3)
x
y <- c(5,6)
y

z<-rbind(x,y)
z 
```

Podemos pasar un vector a una matriz

```{r}
x<-1:10
x

dim(x)<-c(2,5)
x

```

Trasponer matrices:

```{r}
x <- matrix(c(1:9),3)
xtraspuesta <- t(x)
```

Potencialmente se pueden hacer muchas más operaciones que involucren
matrices. Por ejemplo, subconjuntos de una matriz: segundo y cuarto
elemento de la segunda fila:

```{r}
M <- matrix(1:8, nrow=2)
M
M[1,1]
M[1,]
M[,2]
M[2,c(2,4)]
```

## Herramientas de programación

### Objetos adicionales

#### Arreglos

Crear arreglos: La única diferencia con matrices es que acepta mas de
dos dimensiones.

Para generarlos:

```{r, eval=FALSE}
mi.arreglo <-array(vector, 
                   dimensiones, 
                   dimnames = etiquetas_dim)
```

Para nombrarlos definimos etiquetas y luego las agregamos. Es mucho
mejor y mas ordenado hacerlo así:

```{r}
dim1 <- c("A1", "A2")
dim2 <- c("B1", "B2", "B3", "B4")
dim3 <- c("C1", "C2", "C3")
```

**Ejemplo de arreglo:** Defino un arreglo de 3 matrices de 2 (filas) x 4
(columnas)

```{r}
x <- array(1:24,
           c(2,4,3),
           dimnames = list(dim1, dim2, dim3))
x
```

Notar la tercera dimensión!

**Subconjuntos de un arreglo:** x[Fila,Columna, Matriz]

```{r}
x[1,2,3]       # 1 fila, 2da columna, 3ra matriz
x[,,3]         # 3era matriz completa
x[,4,]         # 4ta columna de todas las matrices
x[,-1,2]       # Todas las filas, sin la primera columna, de la matriz 2. 
x[-1,c(1,2),3] # Todas las columnas, sin la fila 1, de la matriz 3. 
x[-1,1:2,3]    # Columnas 1 y 2, sin la fila 1, de la matriz 3. 
x[,,1]*2
```

#### Listas

Las listas contienen elementos de diferente tipo: matrices, objetos,
dataframes, vectores, etc.

```{r}
x <- list(c(1:8), "R", TRUE, 2+3i, 5L)
x #separa todo componente
```

Para acceder a un objeto dentro de la lista se debe utilizar DOBLE
CORCHETE:

```{r}
x[[5]]
x[5]
```

Veamos un ejemplo de cómo trabaja:

```{r}
x <- list(Titulacion = c("Economia", "Administracion", "Politica"), 
           Edad =c(25,23,27))
x
```

Al nombrar los componentes dentro de la lista, podemos llamarlos sin
necesidad de los corchetes:

```{r}
x$Titulacion
x[[1]]
x[["Titulacion"]]

x$Edad
x[[2]]
```

Como los componentes dentro de las listas tienen definida una
naturaleza, podemos hacer operaciones con ellas también:

```{r}
x[["Edad"]]*3

x$Edad[c(1,3)]*3
```

Finalmente, tambien podemos crear listas vacias (útil para rellenar
utilizando iteradores):

```{r}
x <-vector("list", length = 10)
```

**Ejemplo de una lista:** Definimos una lista

```{r}
milista <- list(
  
  # Primer elemento sera un vector
  hospitales = c("Van Buren", "Gustavo Fricke", "Salvador"),
  
  # Segundo elemento sera un dataframe
  direccion   = data.frame(
    calle = c("San Ignacio", "Av. Alvarez", "Av. Salvador"),
    ciudad   = c("Valparaíso", "Viña del Mar", "Santiago")
  )
)

milista
```

Llamar a subconjuntos

```{r}
# Retorna el elemento de la lista
milista$hospitales
milista[2]

# Retorna el elemento, pero sin nombre y como vector
milista[[1]]
milista[["hospitales"]]

# Elementos particulares
milista[[1]][3]
milista[[2]][,1]
milista[[2]][1,]
milista[[2]][1,2]
```

Notar que es importante saber el tipo de dato.

#### Dataframes

**Crear un dataframe:** Es básicamente una matriz donde filas y columnas
tienen significado. Contiene tanto valores numericos, carácteres,
variables categóricas, etc.

```{r}
datos <- data.frame(Titulacion = c("Economia", "Administracion", 
                                   "Administracion"),
                    Edad =c(25,23,27), 
                    ocupacion = c(1,0,1))
datos
```

Esto es lo mas cercano a una base de datos. Es uno de los objetos
básicos que veremos muchas veces a lo largo del curso.

**Dimensiones de un dataframe:** Para ver las dimensiones hay que
utilizar nrow(), ncol() o bien dim().

```{r}
nrow(datos)
ncol(datos)
dim(datos)
```

Notar que nrow() y ncol() tambien sirven para matrices.

**Subconjuntos de un dataframe:** Al igual que en las matrices,
utilizamos `[ ]` para acceder a elementos dentro de la base.

```{r}
datos[1,1]
datos[,1]
datos[,-2]
datos[, c(1:2)]
datos[, c("Titulacion")]

# Tambien puedo ocupar $ para llamar. 
datos$Titulacion

# Ojo que esto lo puedo hacer con todo
summary(datos[,2])
summary(datos[,2])[3]
summary(datos[,2])["Max."]
```

**Tibbles:** Una version mas moderna de dataframes. Es la misma idea:
lista de vectores con nombres.

```{r}
Altura <- c(168, 177, 177, 177, 178, 172, 165, 171, 178, 170)
Peso  <- c(88, 72, 85, 95, 71, 69, 61, 61, 51, 75)
M <- cbind(Altura, Peso)
```

Paquete para trabajar con bases de datos (más detalles en secciones 2.3
y 2.4)

```{r}
install.packages("tidyverse") 
library(tibble) # Una libreria dentro de tidyverse. 
misdatos <- as_tibble(M)
misdatos

# Podemos ver los nombres o bien estadistica básica de cada variable. 
names(misdatos)
summary(misdatos)
```

**Agregar columnas a un dataframe:** Podemos agregar variables a la
base. Dos opciones:

```{r}
# Opción 1: utilizando $nombre_columna<-vector
datos$id <- c(1:3)
datos

# Opción 2: utilizando el cbind (al igual que con matrices)
id2<-c(1:3)
datos1 <- cbind(id2,datos) 
datos1
```

**Attach:**

Notación muy inconveniente

```{r}
misdatos$Altura
misdatos$Peso
```

Para evitar escribir datos cada vez que quiera llamar a una variable voy
a utilizar la funcion `attach()`:

```{r}
attach(datos) # para comenzar

# Ahora puedo llamar a sus variables sin utilizar datos
nueva <- Edad * ocupacion 
nueva <- datos$Edad * datos$ocupacion
nueva 

detach(datos) # para terminar
```

Esta es una forma mucho mas conveniente de trabajar con dataframes o
tibble en R.

::: {.alert .alert-block .alert-warning}
<b>Ejercicio 2.2.1:</b> Crear un dataframe

Cree su primera base de datos. Debe armar una tabla igual a la figura.
Tiene 5 minutos. ![Ejercicio](01figuras/ejercicio2.PNG)
:::

Respuesta:

```{r}
ejer <- data.frame(Tipo_animal = c("Perro", "Perro","Gato","Perro", 
                                   "Gato","Gato","Gato"),
                   Color =c("Café","Blanco","Negro","Manchas","Café","Tricolor","Negro"), 
                   Peso = c(7,5,3,4,2,5,4),
                   Pasea=c("Sí","Sí","Sí","No","No","No","Sí"))
```

### Acceder a elementos de un objeto

#### Vectores

Para acceder a los elementos de un objeto debemos utilizar los corchetes
`[ ]`

```{r}
# Veamos en un vector

x<-c("T", "FALSE", 1:9,1+2i,"t", "c","a",6)
class(x)

# Podemos llamar a un objeto de un vector 
x[1]
x[3]
```

De esta manera podemos extraerlo o utilizarlo en diferentes operaciones.
Pero sólo debe ser entre observaciones numericas:

```{r, eval=FALSE}
x[1]+x[6] #de lo contrario R nos arroja un error 
y<-c(1:6, 1+2i)
y[3]+y[7]

#O podemos visualizar a x, pero sin el primer objeto
x[-1]

#O eliminar el primer objeto 
x<-x[-1]
x1 <- x[-1]
```

#### Matrices

Si analizamos los objetos de una matriz:

```{r}
w<-matrix(1:9,3)
w

# Elemento [1,1]
w[1,1]
# Toda la primera columna 
w[,1]
# Toda la segunda fila
w[2,]
# Dos columnas
w[,1:2] # w[,-3]
# Todas las filas menos la primera
w[-1,]
```

#### Listas

Si queremos llamar a un objeto dentro de una lista:

```{r}
z <- list(c(1:8), "R", T, 2+3i, 5L)
z #separa todo componente
```

Para acceder a un objeto dentro de la lista se debe utilizar doble
corchete:

```{r}
z[[1]]

#Y algo dentro de ese objeto 
z[[1]][5]

#Tambien podemos analizar su clasificacion 
class(z[[1]]) #numerico 

#Si es numerico, entonces tambien podemos hacer operaciones 
z[[1]][3]*z[[1]][5]
```

### Tipos de objetos y datos

#### Identificar tipos de objetos

Veamos en un vector cualquiera

```{r}
x<-c("T", FALSE, 1:9,1+2i,"t", "c","a",6)
class(x)
```

Como bien sabemos todo en R es un objeto. Para saber que tipo de objeto
es puedo utilizar la función `class()`:

```{r}
class(datos)
class (x)
```

Note que `class()` identifico que es un "data.frame" y una lista.
También puedo ver los tipos de elementos dentro de un determinado
objeto. Para datos, existen 5 tipos principales, llamados:

1.  **carácteres:** texto. Se escriben con comillas (ej: "3", "swc").
2.  **numéricos:** numeros reales (ej. 2, 15.5).
3.  **enteros:** numeros enteros ("L" le dice a R que guarde esto como
    un entero).
4.  **logical:** valores logicos (ej. TRUE, FALSE).
5.  **complejos:** 1 + 4i (Numero complejos).

#### Identificar tipos de datos

```{r}
# 1. Carácteres
z<-c("a","b")
class(z)

# 2. Números enteros
w<-c(1L,2L,3L) #la L es para obligar que sea entero
class(w)

# 3. Numéricos 
w1 <- c(1,2,3)
class(w1)

# Notar que la L lo obliga a ser entero ¿Qué ocurre si no coloco la L? 

# 4. Valores logicos
v1 <- c(TRUE, FALSE)
class(v1)

# Notar que si estan entre comillas son caracteres, no logical!. 
v<-c("TRUE", "FALSE")
class(v)

# 5. Números complejos 
t<-c(1+2i,1+3i)
class(t)
```

Hay más clases: Date(fechas), Factor(variables categóricas), data.frame,
tibble, list.

#### ¿Importan los tipos de los objetos?

R intenta mantener dentro de un vector el tipo de objeto. Si es que
tratamos de juntar distintos tipos de datos en un vector. Igualar a la
clase. Por ejemplo, si intentamos generar un vector con texto y
número/logical todo será texto:

```{r}
h <- c(TRUE,"a", TRUE, 2)
h
class(h)
```

Si intentamos juntar un "Logical" con un número todo será número:

```{r}
h1 <- c(TRUE,2,3)
h1
class(h1)
```

Aquí carácter todo se va a caracter:

```{r}
x <- c("T", "FALSE", 1:3, 1+2i, "t", "c", "a")
class(x)

y <- c(1:4)
class(y)

y <- c(1,2,3,4)
class(y)
```

Si utilizo el operador `:` para crear vectores lo interpreta como un
*integer*.

#### Forzar a R para que utilice un tipo de dato

Forzar a R a llevar el vector solo a numérico:

```{r}
z <- as.numeric(x)
class(z)
z 
```

`as.numeric()` fuerza al vector a solo tener números. Noten que remplaza
los que no son numérico por NA.

Forzar a R a llevar el vector solo a carácteres:

```{r}
z1 <- as.character(y)
class(z1)
z1
```

Noten que ahora se agregaron las dobles comillas.

Forzar a R a llevar el vector sólo a carácter.

```{r}
x
z2 <- as.logical(x)
class(z2)
z2 
```

Noten que "T" fue aceptado como TRUE!

#### ¿Cómo saber que tipo de datos tengo?

```{r}
# Puedo preguntar a R sobre el tipo. 

is.numeric(y)   # Es numerico?
is.character(y) # Es caracter?
is.logical(y)   # Es logico?

# La respuesta a esta pregunta va a ser un valor lógico
class(is.numeric(y))

# También se puede utilizar la opcion `typeof`
typeof(y)
```

#### Mayúsculas importan

Como vimos en lasección anterior, R es sensible a las mayúsculas. Esto
aplica para nombres de funciones, paquetes, comando y también para los
datos. Por ejemplo:

```{r}
x <- c("A", "a","a","a", "B", "B","b", "A")
length(x)

sum(x == 'a')
sum(x == 'b')
```

Para R las minúsculas y mayúsculas SI IMPORTAN!.

#### Carácteres especiales

Vimos que existen nombres de variables no validos en R. Tambien existe
un conjunto de caracteres invalidos.

-   **NA:** Not Available (missing values)
-   **NaN:** Not a Numbers (ej. 0/0)
-   **Inf:** Infinito (1/0)
-   **-Inf:** Menos infinito

```{r}
0/0
-1/0 
```

#### Missing values

En R, los valores perdidos ("missing values") se representan con el
valor especial `NA` (letras mayusculas N y A - sin comillas). Para saber
si tengo valores `NA` en un objeto, puedo ocupar la funcion `is.na()`:

```{r}
ejemplo <- c(1,3,NA,4)
is.na(ejemplo)

ejemplo[!is.na(ejemplo)]

# El resultado es un vector. Noten que es importante para utilizar algunas funciones:

mean(ejemplo)
mean(ejemplo, na.rm = TRUE)
```

No funciona en el primer caso, si en el segundo. Veremos mas detalles
sobre como tratar missing values (ej. recodificar) en las clases de
manipulacion y analisis de datos.

#### Funciones útiles

```{r}
# Redondear
round(c(2.53, 3.52), 1)

# Estadística simple
x <- c(1,2,3,4,5,6)

mean(x)    # promedio
median(x)  # mediana
sd(x)      # desviacion estandar
sum(x)     # suma del vector
min(x)     # Valor minimo
max(x)     # Valor maximo
range(x)   # rango 
summary(x) # resumen 

# Notar que tienen que ser vectores!
mean(10, 6, 12, 10, 5, 0) 
mean(c(10, 6, 12, 10, 5, 0))

# En el primer caso sólo toma el primer valor! Ojo, siempre un vector. 

# Otras funciones
seq(1,10,2 )                        # Crear secuencias
rep(c(1,2,3),10)                    # Repetir
cut(x,2)                            # subdividir
sample(x, size = 3, replace = TRUE) # Generar un aleatorio

# El analisis de datos es...

Altura = c(168, 177, 177, 177, 178, 172, 165, 171, 178, 170)
Peso  = c(88, 72, 85, 95, 71, 69, 61, 61, 51, 75)
M = cbind(Altura, Peso)

# Paquete para trabajar con bases de datos (más detalles en secciones 2.3 y 2.4)
install.packages("tidyverse") 
library(tibble) # Una libreria dentro de tidyverse. 
misdatos <- as_tibble(M)
misdatos

attach(misdatos)
max(Altura)
min(misdatos$Peso)
detach(misdatos)
```

### Herramientas en R

#### Escribir Códigos

Algunos comentarios con respecto a la escritura de codigos:

1.  Siempre escribir comentarios autocontenidos.
2.  Siempre utilizar índice.

-   Me permite reducir el código.
-   Me permite ver donde estoy también en un código largo.
-   Puedo verlo con ctrl + shift + O o bien en la esquina inferior
    izquierda del script.

3.  Separar códigos largos en varios códigos. Cada código debe tener un
    objetivo claro que debe explicar en una oración.
4.  Escribir códigos en bloques.
5.  Tres consejos básicos de estilo:

-   utilizar `_` para generar variables o bien otra convención.
-   separar entre objetos y operaciones.

#### Condicionales y controladores de flujo

Operadores básicos:

```{r}
rm(list=ls())

# Asignador
a <- 2 * 3
a 

a1 = 2 * 3
a1 

# Nota: Nunca ocupar igual. 

# Igualdad 
TRUE == TRUE 
TRUE == FALSE

# Nota: Para comparar elementos se utiliza doble igual "==".  


# Desigualdad (!=)
TRUE != FALSE 
"Hola" != "Chao"

# Otros comparadores: <, > (>=), (<=) 
3 < 5
5 > 8
5 >= 5

# Nota: No confundir con <- que es para asignar. 

TRUE > FALSE

# Noten que la respuesta en un logical. 

# En vectores y matrices
vector1 <- c(16,9,13)
vector2 <- c(10,12,15)

# Comparar contra un escalar
vector1 > 10
vector2 < 10

# Compararlos entre ellos 
vector1 < vector2

# Veamos en una matriz 
matrix <- matrix(c(vector1, vector2), 
                 byrow = TRUE, 
                 nrow = 2)
matrix

matrix > 10
```

Operador %in%: Un operador muy útil para comparar valores y para evaluar
rápidamente si un valor está dentro de un vector o marco de datos.

```{r}
rm(list=ls())

v1 <- 3
v2 <- 101
t <- c(1,2,3,4,5,6,7,8)

# El valor v1 ¿se encuentra dentro de t?
v1 %in% t 

# Otro ejemplo....
mivector <- c("a", "b", "c", "d")
"a" %in% mivector

# Si no  está en el vector da un FALSE
"h" %in% mivector

# Si le quiero preguntar si NO está, coloco un signo de exclamación al frente. 
!"a" %in% mivector

# Un vector en otro vector 
a <- seq(12, 19, 1)
b <- seq(1, 16, 1)

# Veamos si los elementos de un vector "largo" están en uno "corto" 
b %in% a

# Esto va a ser muy útil cuando trabajemos con bases de datos. 
```

Operadores para seleccionar subconjuntos de datos:

```{r}
y <- c(2,3,3,4,NA,8)
y

# Vamos a seleccionar solo los que no son NA
y1 <- y[!is.na(y)]
y1 

# Noten que utilizamos la funcion is.NA y un operador (!). Más detalles en parte de análisis de datos, pero noten que la idea principal está aquí. 
```

Operadores lógicos:

```{r}
# Operador (&): operador "y"
TRUE & TRUE 
TRUE & FALSE
FALSE & TRUE
FALSE & FALSE 

# Ejemplo 
x <- 12 
x > 5 & x < 11  

# Operador (|): operador "o". Condiciones no excluyentes.
TRUE  | TRUE 
TRUE  | FALSE 
FALSE | TRUE
FALSE | FALSE 

# Ejemplo
y <- 4
y < 5 | y > 15 

# Operador de negación (!)
!TRUE 
!FALSE 

# Combinarlo con funciones 
!is.numeric(5)
!is.numeric("Hello")

# Operadores con vectores 
c(TRUE, TRUE, FALSE) & c(TRUE, FALSE, FALSE)
c(TRUE, TRUE, FALSE) | c(TRUE, FALSE, FALSE)
!c(TRUE,TRUE,FALSE)

# Si utilizo dos "&&" sólo compara el primer elemento del vector
c(TRUE,FALSE,FALSE) || c(TRUE,FALSE,FALSE)
c(TRUE,FALSE,FALSE) && c(TRUE,TRUE, TRUE)
```

#### Condicionales

If:

```{r}
x <- 3
  
#if (condicion){

#  cualquier cosa que quiero que se haga si la condición se cumple 

#}

if (x > 0) {
  
  print("x es número mayor que cero")
  
}

if (x > 0){
  
  print("x es un número mayor que cero ")
  
}

if (x < 0){
  
  print("x es un número menor que cero")
  
}
```

Else:

```{r}
x <- 0

if (x > 0){
  
  print("x es un número positivo")
  
} else{
  
  print("x es un número negativo")
  
}
```

Elseif:

```{r}
x <- 0

if (x > 0){
  
  print("x es mayor que cero")
  
} else if (x == 0){
  
  print("x es igual a cero")
} else{
  
  print("x es menor que cero")
  
}

# Importante: `(%%) corresponde al resto de una división`

x <- 6 

if (x %% 2 == 0){
  
  print("x es divisible por 2")
  
} else if (x %% 3 == 0){
  
  print("x es divisible por 3")
} else {
  
  print("x no es divisible ni por 2 ni por 3")
  
}

# Notar que si la primera condición se cumple, la segunda no se ejecuta aunque sea cierta.  
```

#### Funciones

Idea principal: $f(x) = 2x + 1$, $x \in R$ $f(x) = 'hola' + x$,
$x \in ('pepe', 'pepa', 'marta')$

```{r}
valores <-  c(1,2,3,4)
mean(valores)
```

Algunas cosas adicionales sobre funciones: `n` me permite ver los
argumentos de una función, sin necesidad de ver la documentación. Útil a
veces.

```{r}
# Escribir funciones con un argumento
triple <- function(x){
  
  y <- 3 * x
  return(y)
  
}


triple <- function(x){
  x/2

  
}

triple(500)

# Escribir funciones con mas de un argumento
operacion <- function(a,b){
  
  a*b + a/b
  
  
}

operacion(4,2)

# Escribir funciones fijando opción por defecto.
operacion_defecto <- function(a,b = 1){
  a*b + a/b
  
  
}

operacion_defecto(4)
operacion_defecto(4,0)

# Escribir funciones utilizando if y return.
operacion_condicionales <- function(a,b = 1){
  if (b == 0){
    return(0)
    
  }
  a*b + a/b  
  
}

operacion_condicionales(4,0)

# Funciones con texto 
texto <- function(){
  print("Hola mundo!")
  return(TRUE)
}

texto()

# Funciones por defecto en ambos casos
operacion_dosdefectos <- function(a = 1,b = 1){
  if (b == 0){
    return(0)
    
  }
  
  a*b + a/b  
  
}

operacion_dosdefectos()
```

::: {.alert .alert-block .alert-warning}
<b>Ejercicio 2.2.2:</b> Funciones

Genere una función que sea igual a la división de dos elementos. Coloque
un mensaje que indique cuando la división es indeterminada.
:::

Respuesta:

```{r}
operacion_indeterminada <- function(a,b){
  a/b 
  if (b == 0){
    print("Es indeterminado")
  }
}

operacion_indeterminada(1,0)
```

## Manipulación de bases de datos (Parte I)

### Principios de programación

#### Iteradores

For loop:

```{r}
# Imaginen que queremos mostrar los nombres de un vector de forma reiterada
ciudades <- c("Nueva York", "Paris", "Santiago", "Rancagua")

print(ciudades[1])
print(ciudades[2])
print(ciudades[3])
print(ciudades[4])

# Lo anterior se puede hacer utilizando un iterador.
for (i in 1:4){
  print(ciudades[i])
}

# Utilizando variables ocultas...
for (.j in 1:4){
  print(ciudades[.j])
}

for (.j in 1:length(ciudades)){
  print(ciudades[.j])
}

# o escrito señalando el nombre de cada elemento de un vector. 
for (ciudad in ciudades){
  print(ciudad)
}

# Otro ejemplo:
semana <- c("Domingo",
            "Lunes",
            "Martes",
            "Miercoles",
            "Jueves",
            "Viernes",
            "Sabado")

for (dia in semana)
{
  print(dia)
}
```

For loop con opciones:

```{r}
ciudades <- c("Nueva York", "Paris", "Santiago", "Tokio")

# Agregar opcion break: quiebra el loop
for (ciudad in ciudades){
  if(nchar(ciudad) == 8){
    break
  }
  print(ciudad)
}

# Agregar  Opción next: se salta ese elemento
for (ciudad in ciudades){
  if (nchar(ciudad) == 8){
    next 
  }
  print(ciudad)
}
```

Flexibilizar el iterador:

```{r}
ciudades <- c("Nueva York", "Paris", "Santiago", 
              "Tokio", "Rancagua", "Roma")

# Ahora el tamaño del loop es flexible. Esto es muy inportante para cuando trabajemos con bases de datos. 

for (i in 1:length(ciudades)){
  print(ciudades[i])
}

# Noten que ahora llamo a los elementos dentro de un loop como subconjuntos de un vector. 

# En resumen, dos versiones de lo mismo 

for (i in 1:length(ciudades)){
  print(ciudades[i])
}

for (ciudad in ciudades){
  
  print(ciudad)
}

# Ejemplo: para dejar mensajes 

for (i in 1:length(ciudades)){
  print(paste(ciudades[i], "esta en la posicion",i, 
              "en el vector ciudades"))
}

# Lo anterior es aplicable para inspecciones de bases de datos, por ejemplo, podemos dejar un mensaje

for (i in 1:length(mtcars)){
  print(paste("el promedio de la variable",
              names(mtcars[i]), "es",
              mean(mtcars[,i])))
}
```

While: mientras que...

```{r}
x <- 1 

while (x <= 7){
  print(paste("x es", x))
  
# Actualización 
  x <- x + 1 
}

while (x <= 700){
  print(paste("x es", x))
  # Actualizacion 
  x <- x + 1 
}

# Muy importante la actualización.
```

#### Lapply, Sapply y Vapply

Lapply:

```{r}
nyc <- list(poblacion = 8405837, 
            barrios = c("Manhattan", "Bronx", 
                        "Brooklyn", "Queens", 
                        "Staten Island"))
nyc
```

-   Equivalencia loop y lapply. Quiero saber todas las clases de la
    lista:

```{r}
# Puedo hacer esto con un loop 
for (objeto in nyc){
  print(class(objeto))
}

for (i in 1:length(nyc)){
  print(class(nyc[[i]]))
}

# Pero, si utilizo `lapply()` puedo hacerlo mucho más eficiente. 
# Lapply: que aplica esto como si fuese un `for`. 
lapply(nyc,class)
```

-   Resultado de lapply con vector:

```{r}
# Lapply ejecuta la función, en este caso class, para todo elemento del objeto, en este caso nyc. 

# Si quiero saber el número de carácteres
cities <- c("New york","Paris", "Tokyo", " Rio de Janeiro")
lapply(cities,nchar)
class(lapply(cities,nchar))

# Noten que el resultado aquí es una lista. Si quiero que sea un vector, puedo utilizar la función `unlist()`. 
unlist(lapply(cities,nchar))
class(unlist(lapply(cities,nchar)))
```

-   Lapply como función:

```{r}
precios <- list(2.25, 2.18, 2.89, 2.84, 2.89)

# Creamos una función
multiplicar <- function(x,factor){
  x * factor
}

# Ahora, podemos aplicar lapply y agregar opciones de la función
tresveces <- lapply(precios, multiplicar, factor = 3)
tresveces <- unlist(tresveces)

# Noten que la sintaxis es: objeto, función, opciones. Es decir, igual a lo anterior, pero pudiendo agregar opcionales. 
```

**Sapply:** Es una variacion de `lapply` que sirve para simplificar
`lapply`. Ahora el resultado es un vector, no una lista.

```{r}
cities <- c("New york","Paris", "Tokyo", " Rio de Janeiro")

lapply(cities,nchar)
sapply(cities,nchar)

# Noten que es bastante ordenado. Sin embargo, falla cuando no es fácil ordenar el resultado. 
```

**Vapply:** Es una variación que sirve para definir explícitamente el
tipo de objeto del resultado.

```{r}
vapply(cities, nchar, numeric(1))
```
