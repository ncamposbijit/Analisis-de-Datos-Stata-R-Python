# Data Analysis with R

## Introduction to R and RStudio

### Why use R as a programming language?

-  **Open source:** The license is free.

-  **Versatile:** statistical and econometric analysis + useful programming tasks (e.g., web scraping).

-  **Flexible and reproducible:** ensures reproducibility, is flexible to changes and error detection. 
    
-  **In demand:** Open-source programming languages are increasingly requested in the labor market.

### Key and recurring terms throughout the course

-   **RStudio:** Graphical User Interface. It is designed to make using R easier.
-   **Objects:** Anything you store in R. For example: datasets, variables, lists of names, plots.
-   **Functions:** An operation produced by code that accepts inputs and returns outputs.
-   **Packages:** A set of functions grouped according to their purpose. 
-   **Scripts/Code:** Document that contains all commands used in a data analysis process.

### Learning Resources

::: {style="text-align: justify"}
-   Cheat sheets: material available with a summary of the main commands/packages/functions for different topics.
    Available at: <https://www.rstudio.com/resources/cheatsheets/>
:::

-   Forums and websites:
    -   [Stackoverflow](https://stackoverflow.com/questions/tagged/r)
    -   [Medium](https://preettheman.medium.com/awesome-tricks-every-r-coder-should-know-c4220cd2cfbc)
    -   [The RStudio Blog](https://posit.co/)
-   Books:
    -   [R for Data Science](https://r4ds.had.co.nz/)
    -   [Resources about R in Spanish.](https://posit.co/resources/videos/)
    -   [Bookdown](https://bookdown.org/)
- 

### RStudio Interface

#### Four sections in RStudio

The fundamental ones are: *Scripts, Console, 
Environment/Files/Help*.

- **Scripts:** Where we will develop the code. It is a notebook. 
- **Console:** Where we will see the results.
- **Environment:** Where we will see the data and the information we are generating.
- **Files:** Where we will see the files associated with our projects.
- **Help:** Where we will develop the code. It is a notebook. 

To customize RStudio go to: **Tools -> Global Options**.
There you can change the environment color, font type, layout order. The
idea is to use RStudio in the most intuitive way possible. 

#### Writing comments

It is very important to write comments throughout your code. It is also important to know how to write **good** comments. A very good guide that discusses this and many other things is: [Code and Data for the Social Sciences: A Practitioner's Guide](https://web.stanford.edu/~gentzkow/research/CodeAndData.pdf).

`(#)` to write comments in the script. If I want to mark multiple
lines as comments: `ctrl + shift + c`

#### Indices

It is important to write indices to document your code. To
see it I must type: `ctrl + shift + o`

Titles can be hierarchical:

```{r message=FALSE}
# The most important
## This is a bit less important
### This is a bit less important than the previous one
#### The least important
```

It is important to update it constantly to avoid losing functionality.

### Package installation and help

Packages are basically collections of functions. Packages are installed once, but they are called every time they are used.

#### Libraries

This can be done in two ways:

1.  From the *Packages* tab in the bottom-right corner.

2.  Using commands


```{r message = FALSE, warning = FALSE, results="hide"}
install.packages("dplyr")
```

Many packages at the same time: 

```{r, eval=FALSE}
install.packages(c("dplyr","ggplot2","rio"))
```

Common error: 
```{r, eval=FALSE}
install.packages("dplyr", "ggplot2")
```

In general, it is a good idea to install them at the beginning of your work, since we commonly use the same libraries when doing data analysis. With this function, we tell R to install the package if it is not installed (something typical when we switch computers):

```{r, eval=FALSE}
if(!require(dplyr)) {install.packages("dplyr")}
```

Load libraries: 

```{r, eval=FALSE}
library(dplyr)
```

If we want to see what is inside each package:

```{r, eval=FALSE}
ls("package:dplyr", all = TRUE) #ls = list objects
```

**Important**: the package must be installed once, but loaded every time it is used. There are often updates. To check and install them:


```{r, eval=FALSE}
update.packages()
```

Alternatively, I can link a package to a function using `::`. If I do this, it is not necessary to load the library in order to use that specific function. However, the recommended practice is to load all the libraries of the packages I will use at the beginning.

#### Help function 

About a specific function: 

```{r, eval=FALSE}
help(mean) 
?mean 
mean 
sd
```

About a specific package: 

```{r, eval=FALSE}
help("dplyr") 
library(help="dplyr")
```

#### Useful *Shortcuts*

-   `Esc`: interrupt the current command
-   `Ctrl + s`: save
-   `tab`: autocomplete
-   `Ctrl + Enter`: run line
-   `Ctrl + Shift + C`: comment/uncomment
-   `<-`: Alt + - / option + -
-   `%>%`: Ctrl + Shift + M (*pipe*)
-   `Ctrl + l`: clear console
-   `Ctrl + Alt + b`: run everything up to here (the arrow keys in the console allow you to view the most recent commands used)
-   `Shift + lines`: select multiple lines
-   `Ctrl + f`: find/replace
-   `Ctrl + Up Arrow` (in the console): view previously used commands


#### Clear the R *environment*

Remove all objects:

```{r}
rm(list=ls())
```

Remove only one object 

```{r}
rm(data1)
```

If I want to clear the console, I need to press `Ctrl + L`.

#### Identify the package of a function

Sometimes we want to know which package a given function belongs to. For that, check:
<https://sebastiansauer.github.io/finds_funs/>
`

#### Error común

Por ejemplo:

```{r}
x <- "hola"
```

Noten que en la consola aparece un signo `+`. En estos casos RStudio se
detiene porque probablemente se les olvido un `)` o bien un `#`. En
estos casos hay que corregir el error para ejecutar nuevamente y luego
apretar `esc` en la consola para seguir ejecutando los comandos.


### R Markdown

-   Herramienta para crear informes que sean automáticos, reproducibles
    y con datos que se puedan actualizar en el tiempo.
-   Se pueden generar informes en formato word, pdf, html.
-   R markdown (Rmd) es básicamente una intersección entre texto
    narrativo y código que genera visualizaciones y estimaciones con el
    fin de analizar datos.
-   Rmd puede generar: texto plano, segmentos de co ́digo, gr ́aficos,
    tablas, tableros interactivos.
-   R markdown es especialmente útil:
    -   **Informes rutinarios:** Por ejemplo, informe semanal sobre un
        conjunto de análisis que se actualiza en el tiempo.
    -   **Informes de análisis para un subconjunto de datos:** Por
        ejemplo, informes por país de una base de datos que contiene
        información de distintos países.

#### Conceptos Básicos

-   **Markdown** es el lenguaje que permite escribir documentos en texto
    plano. Los archivos escritos en Markdown tienen la extensión `.md`.
-   **R Markdown** es la variación especifica para R. Permite escribir
    texto plano con Markdown y adjuntar código proveniente de R. Los
    archivos escritos en R Markdown tienen la extensión `.Rmd`.
-   **knirt:** Paquete de R. Sirve para leer los segmentos de código que
    queremos introducir en los reportes.
-   **Pandoc:** Sirve para convertir el output en un archivo con formato
    word/pdf/html. Es un software que viene instalado automáticamente en
    R.

#### Proceso

![Fuente: <https://rmarkdown.rstudio.com/authoring> quick
tour.html](01figuras/C8.1.png)

#### Primer archivo en R Markdown

![](01figuras/C8.2.png) ![](01figuras/C8.3.png)

-   Opciones para elegir el tipo de documento y si quiero confeccionar
    un documento/presentación/un tablero u otros tipos de archivo más
    detallados.
-   Opciones para cambiar título y autor(a).

#### Directorio de trabajo

-   El directorio de trabajo de un archivo `.Rmd` será donde esta
    guardado el archivo con esa extensión.
-   De este modo, R buscará los archivos en la carpeta en donde este
    guardado el archivo `.Rmd`.
-   Para este ejercicio simplemente dejaremos los datos que utilizaremos
    junto al archivo.

#### Componentes de R Markdown

![](01figuras/C8.4.png)

-   YAML: fijar título, fecha y tipo de output.
-   Markdown text: introducir texto.
-   Code Chunk: cargar paquetes, datos, visualizaciones.

![](01figuras/C8.5.png)



### Manipulación de objetos

#### Usar R como calculadora/ejecutar comandos

De manera separada (seleccionar las `ordenes+ctrl+Enter`):

```{r}
2+2 
3*5^(1/2)
```

Ejecutar todas las instrucciones:

```{r}
2+2 ; 3*5^(1/2)
3+4 
5*4 
8/4 
6^7
6^77

log(10) 
log(1)

sqrt(91) # raiz cuadrada

round(7.3) # redondear
```

Incluso grandes operaciones:

```{r}
sqrt(91) + 4892788*673 - (log(4)*round(67893.9181, digits = 2))
```

Incluso uso de números imaginarios:

```{r}
2i+5i+sqrt(25i)
```

#### Creacion de objetos: asignaciones y funciones

con el signo `<-` asignamos valores. También se puede utilizar `=`, pero
no es recomendable, ya que confunde.

```{r}
y <- 2 + 4 
y
```

Las asignaciones son MUDAS. Si no las llamo, no aparecen en la consola.
Lo anterior es una operación sencilla, pero lo que queremos es generar
asignaciones con funciones.

Podemos utilizar funciones. Las funciones son la parte central del uso
de R. Algunas funciones vienen instaladas en R. Otras funciones hay que
obtenerlas desde paquetes. También es posible escribir tus propias
funciones `()`. Las funciones estan por lo general escritas en
paréntesis, por ejemplo `filter()`. Hay ocasiones en que las funciones
estan relacionadas con un paquete específico `dplyr::filter()`.

-   Ejemplo 1: función simple

```{r}
sqrt(49)
```

-   Ejemplo 2: sobre una base de datos

```{r}
summary(mtcars$mpg)
```

*Nota:* mtcars viene incluidad en R.

Para ver mas:

```{r}
data()
```

Otra función:

```{r}
x <- 2 
y <- 3
z <-c(x,y) 
z
```

Uso de funciones aritméticas:

```{r}
mean(z) 
median(z)
```

Relaciones entre objetos:

```{r}
w <- mean(z)
```

Creación de objetos por asignación:

```{r}
a <- 3+10 
b <- 2*4
```

Comparar objetos:

```{r}
a > b
```

Notar que las asignaciones son silenciosas:

```{r}
a 
b 
# o altenativamente utilizar print 
print(a) 
print(b)
```

Creación de objetos usando funciones:

```{r}
valores <- c(a,b)
promedio <- mean(valores)
print(promedio)
promedio
```

Podemos escribir un promedio aquí usando función `mean():`

```{r}
a <- 2 
b <- 5
valores1 <- c(a,b)
promedio1 <-mean(valores1)
print(promedio1)
```

Limpiamos datos nuevamente:

```{r}
rm(list = ls()) 
rm(promedio)
```

#### Creacion de objetos y asignaciones

Es importante espaciar codigos. Definimos dos vectores utilizando la
función `c()`

```{r}
educ <- c(8,12,8,11,16,14,8,10,14,12)
ingreso <- c(325,415,360,380,670,545,350,420,680,465)
```

Calculamos promedio, desviación estándar y correlación

```{r}
mean(ingreso)
promedioingreso <- mean(ingreso)

sd(ingreso)
sdingreso <- sd(ingreso)

cor(educ, ingreso)
coreduing <- cor(educ,ingreso)
```

Graficamos

```{r}
plot(educ, ingreso)
```

Estimar una regresión lineal

```{r}
lm(ingreso ~ educ)
```

::: {.alert .alert-block .alert-warning}
<b>Ejercicio 2.1.1:</b> Nombrar objetos

De los siguientes ejemplos, ¿Cuáles son nombres de variables válidas en
R?

```{r}
# min_height
# max.height
# _age
# .mass
# MaxLength
# Min-length
# 2widths
# Calsius2kelvin
```
:::

### Tipos de objetos

#### Vectores

R opera componente por componente, por lo que es muy sencillo poder
trabajar con vectores y matrices.

Para crear un vector utilizamos la funcion `c()`

```{r}
x <- c(1,2,3,4,5)
#o bien
y <- c(6:8)
```

Veamos los vectores

```{r}
z <- x + y 
z
```

Supongamos los siguientes vectores:

```{r}
x<-c(1:4)
y<-c(1:3)
```

¿Cuál es su longitud?

```{r}
length(x)
length(y)
```

Si no tienen la misma longitud, ¿cual sería el resultado de `x + y`?

```{r}
z <- x + y 
z
```

**IMPORTANTE**: En este caso R realiza la operación de todos modos, pero
nos indica que hay una advertencia de que sus dimensiones difieren. Lo
relevante de los vectores es que sólo se puede concatenar elementos del
mismo tipo, de lo contrario R nos arroja error.

```{r}
x <- rep(1.5:9.5,4) #genera repeticiones de los valores definidos 
y <- c(20:30)
x1 <- c(1,2)
x2 <- c(3,4)
x3 <- c(x1,x2)
x4 <- c(c(1,2), c(3,4))
```

Subconjunto de un vector

```{r}
y[3] # obtener el tercer elemento 
y[2:4] 
y[4:2]
y[c(2,6)]
y[c(2,16)]
```

#### Matrices

##### Definir matrices

Sintaxis general

```{r, eval=FALSE}
mi.matriz <- matrix(vector,
                    ncol = num_columnas, 
                    nrow = num_filas,
                    byrow = valor_logico,
                    dimnames = list(vector_nombres_filas,
                                   vector_nombres_columnas)
)

```

Para crear matrices utilizamos la función `matrix()`

```{r}
x <- matrix (data = c(1,2,3,4), 
             nrow = 2, 
             ncol = 2) 


x1 <- matrix(c(1,2,3,4), 
             2, 
             2)
```

No es necesario poner `data=`, pero por orden mental es mejor hacerlo.

```{r}
x 
x1
```

Notar que por DEFECTO rellena columna por columna. Podemos explicitar
que queremos realizar la matriz fila por fila

```{r}
y <- matrix(data = c(1:4),
          nrow = 3, 
          ncol = 2, 
          byrow = TRUE)
y
```

Podemos saber cual es la dimensión de `x`

```{r}
dim(y)
dim(y)[1] # cantidad de filas
dim(y)[2] # cantidad de columnas

y<- matrix(c(1,2,3,4), nrow=2, ncol=2, byrow=2)
y
```

Los va a repetir!

```{r}
y <- matrix(c(1,2,3,4), nrow=2, ncol=3, byrow= 2) 
y
```

Notar que el orden en cualquier matrix es **filas x columnas**. Podemos
también omitir la cantidad de filas o columnas en la matriz y obtenemos
el mismo resultado

```{r}
y <- matrix(c(1:4), 2, byrow=T)
y 
```

En el caso de crear matrices vacías hay que definir las dimensiones

```{r}
y <- matrix(nrow=3, ncol=3)
y #útil para los loops
```

Darle nombre a las filas y columnas

```{r}
y <- matrix (c(1:4), 2, byrow = FALSE, 
             dimnames=list(c("X1","X2"),c("Y1", "Y2")))
y
```

Se puede realizar desde las funciones colnames y rownames

```{r}
colnames(x) <- c("Variable 1", "Variable 2")
rownames(x) <- c("a1", "a2")
x
```

Añadir filas o columnas a una matriz

```{r}
w <- c(5,6)
```

##### Unir matrices

Unir mediante filas (queda con el nombre del vector la observación)

```{r}
z <- rbind(x,w) 
z
```

Unir mediante columnas

```{r}
z <- cbind(x,w) 
z
```

¿Y si tienen diferente cantidad de filas y/o columnas? repite el vector
o observaci?n con menor longitud

```{r}
x <- matrix(c(1:9),3)
x
y <- c(5,6)
y

z<-rbind(x,y)
z 
```

Podemos pasar un vector a una matriz

```{r}
x<-1:10
x

dim(x)<-c(2,5)
x

```

Trasponer matrices:

```{r}
x <- matrix(c(1:9),3)
xtraspuesta <- t(x)
```

Potencialmente se pueden hacer muchas más operaciones que involucren
matrices. Por ejemplo, subconjuntos de una matriz: segundo y cuarto
elemento de la segunda fila:

```{r}
M <- matrix(1:8, nrow=2)
M
M[1,1]
M[1,]
M[,2]
M[2,c(2,4)]
```

## Herramientas de programación

### Objetos adicionales

#### Arreglos

Crear arreglos: La única diferencia con matrices es que acepta mas de
dos dimensiones.

Para generarlos:

```{r, eval=FALSE}
mi.arreglo <-array(vector, 
                   dimensiones, 
                   dimnames = etiquetas_dim)
```

Para nombrarlos definimos etiquetas y luego las agregamos. Es mucho
mejor y mas ordenado hacerlo así:

```{r}
dim1 <- c("A1", "A2")
dim2 <- c("B1", "B2", "B3", "B4")
dim3 <- c("C1", "C2", "C3")
```

**Ejemplo de arreglo:** Defino un arreglo de 3 matrices de 2 (filas) x 4
(columnas)

```{r}
x <- array(1:24,
           c(2,4,3),
           dimnames = list(dim1, dim2, dim3))
x
```

Notar la tercera dimensión!

**Subconjuntos de un arreglo:** x[Fila,Columna, Matriz]

```{r}
x[1,2,3]       # 1 fila, 2da columna, 3ra matriz
x[,,3]         # 3era matriz completa
x[,4,]         # 4ta columna de todas las matrices
x[,-1,2]       # Todas las filas, sin la primera columna, de la matriz 2. 
x[-1,c(1,2),3] # Todas las columnas, sin la fila 1, de la matriz 3. 
x[-1,1:2,3]    # Columnas 1 y 2, sin la fila 1, de la matriz 3. 
x[,,1]*2
```

#### Listas

Las listas contienen elementos de diferente tipo: matrices, objetos,
dataframes, vectores, etc.

```{r}
x <- list(c(1:8), "R", TRUE, 2+3i, 5L)
x #separa todo componente
```

Para acceder a un objeto dentro de la lista se debe utilizar DOBLE
CORCHETE:

```{r}
x[[5]]
x[5]
```

Veamos un ejemplo de cómo trabaja:

```{r}
x <- list(Titulacion = c("Economia", "Administracion", "Politica"), 
           Edad =c(25,23,27))
x
```

Al nombrar los componentes dentro de la lista, podemos llamarlos sin
necesidad de los corchetes:

```{r}
x$Titulacion
x[[1]]
x[["Titulacion"]]

x$Edad
x[[2]]
```

Como los componentes dentro de las listas tienen definida una
naturaleza, podemos hacer operaciones con ellas también:

```{r}
x[["Edad"]]*3

x$Edad[c(1,3)]*3
```

Finalmente, tambien podemos crear listas vacias (útil para rellenar
utilizando iteradores):

```{r}
x <-vector("list", length = 10)
```

**Ejemplo de una lista:** Definimos una lista

```{r}
milista <- list(
  
  # Primer elemento sera un vector
  hospitales = c("Van Buren", "Gustavo Fricke", "Salvador"),
  
  # Segundo elemento sera un dataframe
  direccion   = data.frame(
    calle = c("San Ignacio", "Av. Alvarez", "Av. Salvador"),
    ciudad   = c("Valparaíso", "Viña del Mar", "Santiago")
  )
)

milista
```

Llamar a subconjuntos

```{r}
# Retorna el elemento de la lista
milista$hospitales
milista[2]

# Retorna el elemento, pero sin nombre y como vector
milista[[1]]
milista[["hospitales"]]

# Elementos particulares
milista[[1]][3]
milista[[2]][,1]
milista[[2]][1,]
milista[[2]][1,2]
```

Notar que es importante saber el tipo de dato.

#### Dataframes

**Crear un dataframe:** Es básicamente una matriz donde filas y columnas
tienen significado. Contiene tanto valores numericos, carácteres,
variables categóricas, etc.

```{r}
datos <- data.frame(Titulacion = c("Economia", "Administracion", 
                                   "Administracion"),
                    Edad =c(25,23,27), 
                    ocupacion = c(1,0,1))
datos
```

Esto es lo mas cercano a una base de datos. Es uno de los objetos
básicos que veremos muchas veces a lo largo del curso.

**Dimensiones de un dataframe:** Para ver las dimensiones hay que
utilizar nrow(), ncol() o bien dim().

```{r}
nrow(datos)
ncol(datos)
dim(datos)
```

Notar que nrow() y ncol() tambien sirven para matrices.

**Subconjuntos de un dataframe:** Al igual que en las matrices,
utilizamos `[ ]` para acceder a elementos dentro de la base.

```{r}
datos[1,1]
datos[,1]
datos[,-2]
datos[, c(1:2)]
datos[, c("Titulacion")]

# Tambien puedo ocupar $ para llamar. 
datos$Titulacion

# Ojo que esto lo puedo hacer con todo
summary(datos[,2])
summary(datos[,2])[3]
summary(datos[,2])["Max."]
```

**Tibbles:** Una version mas moderna de dataframes. Es la misma idea:
lista de vectores con nombres.

```{r}
Altura <- c(168, 177, 177, 177, 178, 172, 165, 171, 178, 170)
Peso  <- c(88, 72, 85, 95, 71, 69, 61, 61, 51, 75)
M <- cbind(Altura, Peso)
```

Paquete para trabajar con bases de datos (más detalles en secciones 2.3
y 2.4)

```{r}
install.packages("tidyverse") 
library(tibble) # Una libreria dentro de tidyverse. 
misdatos <- as_tibble(M)
misdatos

# Podemos ver los nombres o bien estadistica básica de cada variable. 
names(misdatos)
summary(misdatos)
```

**Agregar columnas a un dataframe:** Podemos agregar variables a la
base. Dos opciones:

```{r}
# Opción 1: utilizando $nombre_columna<-vector
datos$id <- c(1:3)
datos

# Opción 2: utilizando el cbind (al igual que con matrices)
id2<-c(1:3)
datos1 <- cbind(id2,datos) 
datos1
```

**Attach:**

Notación muy inconveniente

```{r}
misdatos$Altura
misdatos$Peso
```

Para evitar escribir datos cada vez que quiera llamar a una variable voy
a utilizar la funcion `attach()`:

```{r}
attach(datos) # para comenzar

# Ahora puedo llamar a sus variables sin utilizar datos
nueva <- Edad * ocupacion 
nueva <- datos$Edad * datos$ocupacion
nueva 

detach(datos) # para terminar
```

Esta es una forma mucho mas conveniente de trabajar con dataframes o
tibble en R.

::: {.alert .alert-block .alert-warning}
<b>Ejercicio 2.2.1:</b> Crear un dataframe

Cree su primera base de datos. Debe armar una tabla igual a la figura.
Tiene 5 minutos. ![Ejercicio](01figuras/ejercicio2.PNG)
:::

Respuesta:

```{r}
ejer <- data.frame(Tipo_animal = c("Perro", "Perro","Gato","Perro", 
                                   "Gato","Gato","Gato"),
                   Color =c("Café","Blanco","Negro","Manchas","Café","Tricolor","Negro"), 
                   Peso = c(7,5,3,4,2,5,4),
                   Pasea=c("Sí","Sí","Sí","No","No","No","Sí"))
```

### Acceder a elementos de un objeto

#### Vectores

Para acceder a los elementos de un objeto debemos utilizar los corchetes
`[ ]`

```{r}
# Veamos en un vector

x<-c("T", "FALSE", 1:9,1+2i,"t", "c","a",6)
class(x)

# Podemos llamar a un objeto de un vector 
x[1]
x[3]
```

De esta manera podemos extraerlo o utilizarlo en diferentes operaciones.
Pero sólo debe ser entre observaciones numericas:

```{r, eval=FALSE}
x[1]+x[6] #de lo contrario R nos arroja un error 
y<-c(1:6, 1+2i)
y[3]+y[7]

#O podemos visualizar a x, pero sin el primer objeto
x[-1]

#O eliminar el primer objeto 
x<-x[-1]
x1 <- x[-1]
```

#### Matrices

Si analizamos los objetos de una matriz:

```{r}
w<-matrix(1:9,3)
w

# Elemento [1,1]
w[1,1]
# Toda la primera columna 
w[,1]
# Toda la segunda fila
w[2,]
# Dos columnas
w[,1:2] # w[,-3]
# Todas las filas menos la primera
w[-1,]
```

#### Listas

Si queremos llamar a un objeto dentro de una lista:

```{r}
z <- list(c(1:8), "R", T, 2+3i, 5L)
z #separa todo componente
```

Para acceder a un objeto dentro de la lista se debe utilizar doble
corchete:

```{r}
z[[1]]

#Y algo dentro de ese objeto 
z[[1]][5]

#Tambien podemos analizar su clasificacion 
class(z[[1]]) #numerico 

#Si es numerico, entonces tambien podemos hacer operaciones 
z[[1]][3]*z[[1]][5]
```

### Tipos de objetos y datos

#### Identificar tipos de objetos

Veamos en un vector cualquiera

```{r}
x<-c("T", FALSE, 1:9,1+2i,"t", "c","a",6)
class(x)
```

Como bien sabemos todo en R es un objeto. Para saber que tipo de objeto
es puedo utilizar la función `class()`:

```{r}
class(datos)
class (x)
```

Note que `class()` identifico que es un "data.frame" y una lista.
También puedo ver los tipos de elementos dentro de un determinado
objeto. Para datos, existen 5 tipos principales, llamados:

1.  **carácteres:** texto. Se escriben con comillas (ej: "3", "swc").
2.  **numéricos:** numeros reales (ej. 2, 15.5).
3.  **enteros:** numeros enteros ("L" le dice a R que guarde esto como
    un entero).
4.  **logical:** valores logicos (ej. TRUE, FALSE).
5.  **complejos:** 1 + 4i (Numero complejos).

#### Identificar tipos de datos

```{r}
# 1. Carácteres
z<-c("a","b")
class(z)

# 2. Números enteros
w<-c(1L,2L,3L) #la L es para obligar que sea entero
class(w)

# 3. Numéricos 
w1 <- c(1,2,3)
class(w1)

# Notar que la L lo obliga a ser entero ¿Qué ocurre si no coloco la L? 

# 4. Valores logicos
v1 <- c(TRUE, FALSE)
class(v1)

# Notar que si estan entre comillas son caracteres, no logical!. 
v<-c("TRUE", "FALSE")
class(v)

# 5. Números complejos 
t<-c(1+2i,1+3i)
class(t)
```

Hay más clases: Date(fechas), Factor(variables categóricas), data.frame,
tibble, list.

#### ¿Importan los tipos de los objetos?

R intenta mantener dentro de un vector el tipo de objeto. Si es que
tratamos de juntar distintos tipos de datos en un vector. Igualar a la
clase. Por ejemplo, si intentamos generar un vector con texto y
número/logical todo será texto:

```{r}
h <- c(TRUE,"a", TRUE, 2)
h
class(h)
```

Si intentamos juntar un "Logical" con un número todo será número:

```{r}
h1 <- c(TRUE,2,3)
h1
class(h1)
```

Aquí carácter todo se va a caracter:

```{r}
x <- c("T", "FALSE", 1:3, 1+2i, "t", "c", "a")
class(x)

y <- c(1:4)
class(y)

y <- c(1,2,3,4)
class(y)
```

Si utilizo el operador `:` para crear vectores lo interpreta como un
*integer*.

#### Forzar a R para que utilice un tipo de dato

Forzar a R a llevar el vector solo a numérico:

```{r}
z <- as.numeric(x)
class(z)
z 
```

`as.numeric()` fuerza al vector a solo tener números. Noten que remplaza
los que no son numérico por NA.

Forzar a R a llevar el vector solo a carácteres:

```{r}
z1 <- as.character(y)
class(z1)
z1
```

Noten que ahora se agregaron las dobles comillas.

Forzar a R a llevar el vector sólo a carácter.

```{r}
x
z2 <- as.logical(x)
class(z2)
z2 
```

Noten que "T" fue aceptado como TRUE!

#### ¿Cómo saber que tipo de datos tengo?

```{r}
# Puedo preguntar a R sobre el tipo. 

is.numeric(y)   # Es numerico?
is.character(y) # Es caracter?
is.logical(y)   # Es logico?

# La respuesta a esta pregunta va a ser un valor lógico
class(is.numeric(y))

# También se puede utilizar la opcion `typeof`
typeof(y)
```

#### Mayúsculas importan

Como vimos en lasección anterior, R es sensible a las mayúsculas. Esto
aplica para nombres de funciones, paquetes, comando y también para los
datos. Por ejemplo:

```{r}
x <- c("A", "a","a","a", "B", "B","b", "A")
length(x)

sum(x == 'a')
sum(x == 'b')
```

Para R las minúsculas y mayúsculas SI IMPORTAN!.

#### Carácteres especiales

Vimos que existen nombres de variables no validos en R. Tambien existe
un conjunto de caracteres invalidos.

-   **NA:** Not Available (missing values)
-   **NaN:** Not a Numbers (ej. 0/0)
-   **Inf:** Infinito (1/0)
-   **-Inf:** Menos infinito

```{r}
0/0
-1/0 
```

#### Missing values

En R, los valores perdidos ("missing values") se representan con el
valor especial `NA` (letras mayusculas N y A - sin comillas). Para saber
si tengo valores `NA` en un objeto, puedo ocupar la funcion `is.na()`:

```{r}
ejemplo <- c(1,3,NA,4)
is.na(ejemplo)

ejemplo[!is.na(ejemplo)]

# El resultado es un vector. Noten que es importante para utilizar algunas funciones:

mean(ejemplo)
mean(ejemplo, na.rm = TRUE)
```

No funciona en el primer caso, si en el segundo. Veremos mas detalles
sobre como tratar missing values (ej. recodificar) en las clases de
manipulacion y analisis de datos.

#### Funciones útiles

```{r}
# Redondear
round(c(2.53, 3.52), 1)

# Estadística simple
x <- c(1,2,3,4,5,6)

mean(x)    # promedio
median(x)  # mediana
sd(x)      # desviacion estandar
sum(x)     # suma del vector
min(x)     # Valor minimo
max(x)     # Valor maximo
range(x)   # rango 
summary(x) # resumen 

# Notar que tienen que ser vectores!
mean(10, 6, 12, 10, 5, 0) 
mean(c(10, 6, 12, 10, 5, 0))

# En el primer caso sólo toma el primer valor! Ojo, siempre un vector. 

# Otras funciones
seq(1,10,2 )                        # Crear secuencias
rep(c(1,2,3),10)                    # Repetir
cut(x,2)                            # subdividir
sample(x, size = 3, replace = TRUE) # Generar un aleatorio

# El analisis de datos es...

Altura = c(168, 177, 177, 177, 178, 172, 165, 171, 178, 170)
Peso  = c(88, 72, 85, 95, 71, 69, 61, 61, 51, 75)
M = cbind(Altura, Peso)

# Paquete para trabajar con bases de datos (más detalles en secciones 2.3 y 2.4)
install.packages("tidyverse") 
library(tibble) # Una libreria dentro de tidyverse. 
misdatos <- as_tibble(M)
misdatos

attach(misdatos)
max(Altura)
min(misdatos$Peso)
detach(misdatos)
```

### Herramientas en R

#### Escribir Códigos

Algunos comentarios con respecto a la escritura de codigos:

1.  Siempre escribir comentarios autocontenidos.
2.  Siempre utilizar índice.

-   Me permite reducir el código.
-   Me permite ver donde estoy también en un código largo.
-   Puedo verlo con ctrl + shift + O o bien en la esquina inferior
    izquierda del script.

3.  Separar códigos largos en varios códigos. Cada código debe tener un
    objetivo claro que debe explicar en una oración.
4.  Escribir códigos en bloques.
5.  Tres consejos básicos de estilo:

-   utilizar `_` para generar variables o bien otra convención.
-   separar entre objetos y operaciones.

#### Condicionales y controladores de flujo

Operadores básicos:

```{r}
rm(list=ls())

# Asignador
a <- 2 * 3
a 

a1 = 2 * 3
a1 

# Nota: Nunca ocupar igual. 

# Igualdad 
TRUE == TRUE 
TRUE == FALSE

# Nota: Para comparar elementos se utiliza doble igual "==".  


# Desigualdad (!=)
TRUE != FALSE 
"Hola" != "Chao"

# Otros comparadores: <, > (>=), (<=) 
3 < 5
5 > 8
5 >= 5

# Nota: No confundir con <- que es para asignar. 

TRUE > FALSE

# Noten que la respuesta en un logical. 

# En vectores y matrices
vector1 <- c(16,9,13)
vector2 <- c(10,12,15)

# Comparar contra un escalar
vector1 > 10
vector2 < 10

# Compararlos entre ellos 
vector1 < vector2

# Veamos en una matriz 
matrix <- matrix(c(vector1, vector2), 
                 byrow = TRUE, 
                 nrow = 2)
matrix

matrix > 10
```

Operador %in%: Un operador muy útil para comparar valores y para evaluar
rápidamente si un valor está dentro de un vector o marco de datos.

```{r}
rm(list=ls())

v1 <- 3
v2 <- 101
t <- c(1,2,3,4,5,6,7,8)

# El valor v1 ¿se encuentra dentro de t?
v1 %in% t 

# Otro ejemplo....
mivector <- c("a", "b", "c", "d")
"a" %in% mivector

# Si no  está en el vector da un FALSE
"h" %in% mivector

# Si le quiero preguntar si NO está, coloco un signo de exclamación al frente. 
!"a" %in% mivector

# Un vector en otro vector 
a <- seq(12, 19, 1)
b <- seq(1, 16, 1)

# Veamos si los elementos de un vector "largo" están en uno "corto" 
b %in% a

# Esto va a ser muy útil cuando trabajemos con bases de datos. 
```

Operadores para seleccionar subconjuntos de datos:

```{r}
y <- c(2,3,3,4,NA,8)
y

# Vamos a seleccionar solo los que no son NA
y1 <- y[!is.na(y)]
y1 

# Noten que utilizamos la funcion is.NA y un operador (!). Más detalles en parte de análisis de datos, pero noten que la idea principal está aquí. 
```

Operadores lógicos:

```{r}
# Operador (&): operador "y"
TRUE & TRUE 
TRUE & FALSE
FALSE & TRUE
FALSE & FALSE 

# Ejemplo 
x <- 12 
x > 5 & x < 11  

# Operador (|): operador "o". Condiciones no excluyentes.
TRUE  | TRUE 
TRUE  | FALSE 
FALSE | TRUE
FALSE | FALSE 

# Ejemplo
y <- 4
y < 5 | y > 15 

# Operador de negación (!)
!TRUE 
!FALSE 

# Combinarlo con funciones 
!is.numeric(5)
!is.numeric("Hello")

# Operadores con vectores 
c(TRUE, TRUE, FALSE) & c(TRUE, FALSE, FALSE)
c(TRUE, TRUE, FALSE) | c(TRUE, FALSE, FALSE)
!c(TRUE,TRUE,FALSE)

# Si utilizo dos "&&" sólo compara el primer elemento del vector
c(TRUE,FALSE,FALSE) || c(TRUE,FALSE,FALSE)
c(TRUE,FALSE,FALSE) && c(TRUE,TRUE, TRUE)
```

#### Condicionales

If:

```{r}
x <- 3
  
#if (condicion){

#  cualquier cosa que quiero que se haga si la condición se cumple 

#}

if (x > 0) {
  
  print("x es número mayor que cero")
  
}

if (x > 0){
  
  print("x es un número mayor que cero ")
  
}

if (x < 0){
  
  print("x es un número menor que cero")
  
}
```

Else:

```{r}
x <- 0

if (x > 0){
  
  print("x es un número positivo")
  
} else{
  
  print("x es un número negativo")
  
}
```

Elseif:

```{r}
x <- 0

if (x > 0){
  
  print("x es mayor que cero")
  
} else if (x == 0){
  
  print("x es igual a cero")
} else{
  
  print("x es menor que cero")
  
}

# Importante: `(%%) corresponde al resto de una división`

x <- 6 

if (x %% 2 == 0){
  
  print("x es divisible por 2")
  
} else if (x %% 3 == 0){
  
  print("x es divisible por 3")
} else {
  
  print("x no es divisible ni por 2 ni por 3")
  
}

# Notar que si la primera condición se cumple, la segunda no se ejecuta aunque sea cierta.  
```

#### Funciones

Idea principal: $f(x) = 2x + 1$, $x \in R$ $f(x) = 'hola' + x$,
$x \in ('pepe', 'pepa', 'marta')$

```{r}
valores <-  c(1,2,3,4)
mean(valores)
```

Algunas cosas adicionales sobre funciones: `n` me permite ver los
argumentos de una función, sin necesidad de ver la documentación. Útil a
veces.

```{r}
# Escribir funciones con un argumento
triple <- function(x){
  
  y <- 3 * x
  return(y)
  
}


triple <- function(x){
  x/2

  
}

triple(500)

# Escribir funciones con mas de un argumento
operacion <- function(a,b){
  
  a*b + a/b
  
  
}

operacion(4,2)

# Escribir funciones fijando opción por defecto.
operacion_defecto <- function(a,b = 1){
  a*b + a/b
  
  
}

operacion_defecto(4)
operacion_defecto(4,0)

# Escribir funciones utilizando if y return.
operacion_condicionales <- function(a,b = 1){
  if (b == 0){
    return(0)
    
  }
  a*b + a/b  
  
}

operacion_condicionales(4,0)

# Funciones con texto 
texto <- function(){
  print("Hola mundo!")
  return(TRUE)
}

texto()

# Funciones por defecto en ambos casos
operacion_dosdefectos <- function(a = 1,b = 1){
  if (b == 0){
    return(0)
    
  }
  
  a*b + a/b  
  
}

operacion_dosdefectos()
```

::: {.alert .alert-block .alert-warning}
<b>Ejercicio 2.2.2:</b> Funciones

Genere una función que sea igual a la división de dos elementos. Coloque
un mensaje que indique cuando la división es indeterminada.
:::

Respuesta:

```{r}
operacion_indeterminada <- function(a,b){
  a/b 
  if (b == 0){
    print("Es indeterminado")
  }
}

operacion_indeterminada(1,0)
```

## Manipulación de bases de datos (Parte I)

### Principios de programación

#### Iteradores

For loop:

```{r}
# Imaginen que queremos mostrar los nombres de un vector de forma reiterada
ciudades <- c("Nueva York", "Paris", "Santiago", "Rancagua")

print(ciudades[1])
print(ciudades[2])
print(ciudades[3])
print(ciudades[4])

# Lo anterior se puede hacer utilizando un iterador.
for (i in 1:4){
  print(ciudades[i])
}

# Utilizando variables ocultas...
for (.j in 1:4){
  print(ciudades[.j])
}

for (.j in 1:length(ciudades)){
  print(ciudades[.j])
}

# o escrito señalando el nombre de cada elemento de un vector. 
for (ciudad in ciudades){
  print(ciudad)
}

# Otro ejemplo:
semana <- c("Domingo",
            "Lunes",
            "Martes",
            "Miercoles",
            "Jueves",
            "Viernes",
            "Sabado")

for (dia in semana)
{
  print(dia)
}
```

For loop con opciones:

```{r}
ciudades <- c("Nueva York", "Paris", "Santiago", "Tokio")

# Agregar opcion break: quiebra el loop
for (ciudad in ciudades){
  if(nchar(ciudad) == 8){
    break
  }
  print(ciudad)
}

# Agregar  Opción next: se salta ese elemento
for (ciudad in ciudades){
  if (nchar(ciudad) == 8){
    next 
  }
  print(ciudad)
}
```

Flexibilizar el iterador:

```{r}
ciudades <- c("Nueva York", "Paris", "Santiago", 
              "Tokio", "Rancagua", "Roma")

# Ahora el tamaño del loop es flexible. Esto es muy inportante para cuando trabajemos con bases de datos. 

for (i in 1:length(ciudades)){
  print(ciudades[i])
}

# Noten que ahora llamo a los elementos dentro de un loop como subconjuntos de un vector. 

# En resumen, dos versiones de lo mismo 

for (i in 1:length(ciudades)){
  print(ciudades[i])
}

for (ciudad in ciudades){
  
  print(ciudad)
}

# Ejemplo: para dejar mensajes 

for (i in 1:length(ciudades)){
  print(paste(ciudades[i], "esta en la posicion",i, 
              "en el vector ciudades"))
}

# Lo anterior es aplicable para inspecciones de bases de datos, por ejemplo, podemos dejar un mensaje

for (i in 1:length(mtcars)){
  print(paste("el promedio de la variable",
              names(mtcars[i]), "es",
              mean(mtcars[,i])))
}
```

While: mientras que...

```{r}
x <- 1 

while (x <= 7){
  print(paste("x es", x))
  
# Actualización 
  x <- x + 1 
}

while (x <= 700){
  print(paste("x es", x))
  # Actualizacion 
  x <- x + 1 
}

# Muy importante la actualización.
```

#### Lapply, Sapply y Vapply

Lapply:

```{r}
nyc <- list(poblacion = 8405837, 
            barrios = c("Manhattan", "Bronx", 
                        "Brooklyn", "Queens", 
                        "Staten Island"))
nyc
```

-   Equivalencia loop y lapply. Quiero saber todas las clases de la
    lista:

```{r}
# Puedo hacer esto con un loop 
for (objeto in nyc){
  print(class(objeto))
}

for (i in 1:length(nyc)){
  print(class(nyc[[i]]))
}

# Pero, si utilizo `lapply()` puedo hacerlo mucho más eficiente. 
# Lapply: que aplica esto como si fuese un `for`. 
lapply(nyc,class)
```

-   Resultado de lapply con vector:

```{r}
# Lapply ejecuta la función, en este caso class, para todo elemento del objeto, en este caso nyc. 

# Si quiero saber el número de carácteres
cities <- c("New york","Paris", "Tokyo", " Rio de Janeiro")
lapply(cities,nchar)
class(lapply(cities,nchar))

# Noten que el resultado aquí es una lista. Si quiero que sea un vector, puedo utilizar la función `unlist()`. 
unlist(lapply(cities,nchar))
class(unlist(lapply(cities,nchar)))
```

-   Lapply como función:

```{r}
precios <- list(2.25, 2.18, 2.89, 2.84, 2.89)

# Creamos una función
multiplicar <- function(x,factor){
  x * factor
}

# Ahora, podemos aplicar lapply y agregar opciones de la función
tresveces <- lapply(precios, multiplicar, factor = 3)
tresveces <- unlist(tresveces)

# Noten que la sintaxis es: objeto, función, opciones. Es decir, igual a lo anterior, pero pudiendo agregar opcionales. 
```

**Sapply:** Es una variacion de `lapply` que sirve para simplificar
`lapply`. Ahora el resultado es un vector, no una lista.

```{r}
cities <- c("New york","Paris", "Tokyo", " Rio de Janeiro")

lapply(cities,nchar)
sapply(cities,nchar)

# Noten que es bastante ordenado. Sin embargo, falla cuando no es fácil ordenar el resultado. 
```

**Vapply:** Es una variación que sirve para definir explícitamente el
tipo de objeto del resultado.

```{r}
vapply(cities, nchar, numeric(1))
```

## Manipulación de bases de datos (Parte II)

Ya sabemos cargar datos. Ahora vamos a hacer el primer proceso para
analizar cualquier base de datos.

### Funciones clave

`Tidyverse` es una colección de paquetes de R. `Tidyverse` contiene
múltiples paquetes que iremos utilizando. Incluye: `dplyr`, `ggplot2`,
`tidyr`, `stringr`, `tibble`, `purrr`, `magrittr` y `forcats`. Una
paquete clave es `dplyr` que contiene muchas funciones para trabajar con
bases de datos.

Instalamos tidyverse:

```{r}
install.packages("tidyverse")
library(tidyverse)
library(pacman)
p_load(tidyverse)
```

### Operador piping

Piping `%>%`: `crtrl + shift + m`. Paquete asociado: `magrittr`

```{r}
p_load(magrittr)
```

1.  Operador que permite encadenar las funciones para realizar de manera
    sencilla transformaciones complejas en las bases de datos.
2.  Lo que dice es pasar el elemento que esta a su izquierda como un
    argumento de la función que tiene a la derecha.
3.  Coloca el énfasis en las acciones. Pasa un output intermedio de una
    función a la siguiente.
4.  `magrittr` es el paquete que permite ocupar `piping`. `piping` se
    utiliza mucho con las librerias de `tidyverse` y `dplyr` enfocadas
    en análisis de datos.
5.  Excelente cuando existe una secuencia de acciones/operaciones que
    queremos realizar.

```{r}
data(iris)

# Ejemplo 1: usar pipe como encadenador 
head(iris, n = 4)

# Con piping
iris %>% head(n = 4)

# Ejemplo 2: obtener número total de observaciones y un promedio. 
summarize(mtcars, 
           media = mean(disp))

mtcars %>% summarize(promedio = mean(disp))

# Con piping 
mtcars %>%
  filter(mpg > 20) %>% 
  summarise(promedio = mean(disp))

promedio_mpg_20 <- mtcars %>%
                   filter(mpg > 20) %>% 
                   summarise(promedio = mean(disp))
promedio_mpg_20 
```

### Proceso de análisis de datos (Parte I): cargar, inspeccionar y limpiar

Preámbulo:

```{r}
# Limpiar
rm(list = ls())

# Cargamos paquetes que vamos a utilizar
library(pacman)
p_load(
  rio,        # Importar/Exportar datos 
  here,       # Determinar las rutas de mi carpeta 
  tidyverse,  # Analisis de datos y visualización
  magrittr,   # Para utilizar operador %>%  
  janitor     # Para análisis de datos
)

# Importamos datos
datos <- import(here("datos", "Data.xlsx"), which = "hoja1") 
```

Inspeccionar:

```{r}
# Visión general 
datos 
view(datos)

# Para una inspección detallada 
p_load(skimr)
skim(datos)
str(datos)

# Mirar algunas filas, columnas, etc.

head(datos)     # muestra las 6 primeras filas 
tail(datos)     # últimas 6 filas 
head(datos, 11) # podemos pedir m?s de 6 
tail(datos, 3)  # o menos de 6

# Mirar nombre variables/columnas
names(datos)
datos %>% names()

# `names()` también puede ser 
names(datos) <- c("YEAR", "GDP", "GROSS_EXPORTS", 
                  "GROSS_IMPORTS", "NET_EXPORTS" )
names(datos)

# Mirar filas 
row.names(datos)
row.names(mtcars)

# Mirar la cantidad de variables de la base de datos
length(datos) # columnas o variables
dim(datos) 
ncol(datos) 
nrow(datos)

# ¿Qué tipo de objeto es? 
class(datos)

# También podemos inspeccionar elementos específicos
datos<- import(here("datos", "Data.xlsx"), which = "hoja1") 

# Si queremos ver la columna de GDP
datos$gdp
datos[2]
datos[,2]

# Para llamarlos solo por su nombre recordar ocupar `attach()`
attach(datos)
gdp
detach(datos)

# Si queremos un objeto dentro de una variable 
datos$gdp[7]
datos[7,2]      #[fila, columna]
datos[7,"gdp"]

# Si queremos seleccionar parte de la columna 
datos$gdp[5:10]

# o bien (solo por `attach()`)
attach(datos)
gdp[1:2]

# o bien 
datos[1:2,2] # mostrar las filas 1:2, de la columna 2

# `table()` me permite hacer una tabla sencilla de frecuencias
table(datos$year)
attach(datos)
table(year)
detach(datos)
```

::: {.alert .alert-block .alert-warning}
<b>Ejercicio 2.4.1:</b> Utilizando el operador pipping, mostrar las
últimas 2 filas de las primeras 11 filas.
:::

Limpiar:

```{r}
names(datos) <- c("YEAR", "GDP", "GROSS_EXPORTS", 
                  "GROSS_IMPORTS", "NET_EXPORTS" )
names(datos)

# La función `clean_names()` del paquete `janitor` estandariza nombres: 

datos_nuevos <- clean_names(datos)
names(datos)
names(datos_nuevos)
```

Renombrar variables:

```{r}
rm(list = ls())

datos<- import(here("datos", "Data.xlsx"), which = "hoja1") 

# Función para renombrar variables. Sintaxis: rename(nuevonombre = viejonombre)

# Escribamos esto, pero con `piping`
datos_renombrados <- datos %>% 
                     rename(tiempo = year, 
                     pib = gdp, 
                     exportaciones = gross_exports)
names(datos_renombrados)
rm(datos_renombrados)
```

Seleccionar variables o columnas:

```{r}
rm(list= ls())
datos<- import(here("datos", "Data.xlsx"), which = "hoja1") 

# select() de `dplyr` permite seleccionar variables
datos_select <- datos %>% 
                select(year, gdp)  

datos_select1 <- datos %>% 
  select(c(1:4))

datos_select1 <- datos %>% 
  select(c(1:ncol(datos)-1))  

# También puedo seleccionar en base a un criterio (Sólo sirve para string)
datos_select2 <- datos %>% 
  select(year, contains("Gross"))

# Con `select` también se puede renombrar 
datos_select_renombrados <- datos %>% 
                            select(tiempo = year, 
                                    pib = gdp)

# Una opción es ocupar select con `everything()` para ordeanar mis columnas. 
datos_select_ordenados <- datos %>% 
                        select(gdp, year, everything()) 
```

Remover columnas:

```{r}
# La idea aqui es decir: todas se quedan, menos las que pongo aquí. 
datos_select_remover <- datos %>% 
                      select(-c(gdp, year)) 
```

Mirar si hay duplicados. En ocasiones es importante revisar si hay
duplicados. El paquete `dplyr` contiene `distinct()`. Esta función
examina cada fila y reduce los datos solo a las que sean valores
diferentes:

```{r}
datos1 <- datos %>% distinct()

# ¿Cuantos duplicados?
nrow(datos)
nrow(datos1)

dif <- nrow(datos) - nrow(datos1) 
dif

```

### Proceso de análisis de datos (Parte II): cargar, inspeccionar y limpiar

Cargar:

```{r}
# Limpiamos consola
rm(list = ls())

# Cargamos paquetes que vamos a utilizar
pacman::p_load(
  rio,        # importar/exportar datos. 
  here,       # escribir rutas de las carpetas.  
  janitor,    # limpiar datos y tablas.
  tidyverse,  # Manejo de bases de datos y visualización. 
  magrittr,    # Permite utilizar operador %>% (piping). 
  skimr,       # Inspeccionar datos
  inspectdf,   # Inspeccionar datos
  gapminder    # Base de datos con información de países. 
)
data("gapminder")
gapminder %>% view()

# Cargamos datos que vienen incluidos en R. 
data(starwars) 
starwars 
```

Inspeccionar datos:

```{r}
#  Inspect_cat() retorna una base de datos que resume características de un data.frame.
inspeccion <- inspect_cat(starwars)
inspeccion
class(inspeccion)

# Las columnas son: 

# col_names: nombre de cada columna
# cnt: número de valores únicos por nivel
# common: el nivel más común
# common_pcnt: el porcentaje de ocurrencia del nivel más común.
# levels: una lista de dataframes (tibbles) cada uno con tablas de frecuencia para todos los niveles. 

# Notar que una de las columnas de un data frame pueden ser listas: 
inspeccion[1,5]
inspeccion[2,5]
inspeccion[3,5]
inspeccion[4,5]
inspeccion[5,5]

# Ahora, si quiero ver el contenido, debo utilizar doble paréntesis cuadrado
inspeccion[1,5]      # Con el nombre
inspeccion[[1,5]]    # El contenido
inspeccion[[5]]      # El contenido de todas las filas, en este caso, listas
inspeccion[[5]][[1]]
inspeccion[[5]][[2]]

# Una forma más simple de mirar esta información es:
inspeccion$levels$eye_color
inspeccion[[5]][[1]]

# Otra cosa interesante de este paquete es la función `show_plot()`
starwars %>% inspect_cat() %>% show_plot()

# Esta función permite ver las categorías de cada variable categórica. Noten que las zonas en gris son los NA. 
```

Limpiar bases de datos (continuación):

```{r}
rm(list= ls())

datos<- import(here("datos", "Data.xlsx"), which = "hoja1") 
```

-   Seleccionar columnas:

```{r}
# Vimos que `select()` es parte importante. `select()` puede ser utilizado con varias funciones adicionales: 

# 1. everything () - todas las otras columnas no mencionadas.
datos_everything <- datos %>% 
  select (year, gdp, everything()) 

# 2. last_col () - la última columna.
datos_last_col <- datos %>% 
  select(year, last_col())

# 3. where () - aplicar una función a todas las columnas y 
#               selecciona solo las que cumple esta condición 
#               (es decir, cuando es verdadera). 
datos_where <- datos %>% 
  select(where(is.logical))

# 4. contains () - columns containing a character string
datos_contains <- datos %>% 
  select(contains("exports"))

# 5. starts_with () - selecciona la variable si se tiene un prefijo determinado
datos_starts_with <- datos %>% 
                     select(starts_with("gross_")) 

# 6. ends_with () - selecciona la variable si se tiene un sufijo determinado
datos_ends_with <- datos %>% 
  select(ends_with("_imports")) 

# 7. matches () - aplicar una expresión regular 
datos_matches <- datos %>% 
  select(matches("gross|gdp"))

# 8. any_of () - la selecciona si la columna existe pero NO retorna error 
#                si no la encuentra. 
datos_any_of  <-  datos %>% 
  select(any_of(c("year", "gdp", "cualquiercosa")))
```

-   Manipulación de NAs: Con vectores. Los NA son parte importante de la
    limpieza de los datos. Recordemos que la función `is.na()` nos
    permite identificarlos.

```{r}
x <- c(1,2,NA,NA,5)
malos <- is.na(x)  
malos
class(malos)

# Si queremos eliminar los NA es cosa de colocar un vector sobre otro
x[!malos]
x[!is.na(x)]

x <- x[!malos]
x
```

-   Manipulación de NAs: con `complete cases()`

```{r}
# Miremos un caso más práctico con iris
summary(iris)
skim(iris)
data("iris")

# Generar NA en la base de datos (después veremos esto en detalle ahora concéntrense solo en los NA)
iris$Sepal.Length<-ifelse(iris$Sepal.Length<5, NA,iris$Sepal.Length)

# Dos opciones: 

  # (i) como antes
  malos <- is.na(iris$Sepal.Length)
  iris2 <- iris[!malos,] 
  iris2

  # (ii) utilizando `complete.cases()`
  completos <- complete.cases(iris$Sepal.Length)
  head(completos, 100) 

  # Creamos una base nueva solo con casos completos. 
  iris3 <- iris[completos,] 
  head(iris3)  
  summary(iris3) 
```

## Manipulación de bases de datos (Parte III)

### Crear Variables

#### Crear variables binarias

Ahora vamos a ver como crear variables dicótomas o binarias. Estas
variables son muy importantes para hacer análisis de datos. Vamos a
utilizar la función `ifelse()`.

```{r}
rm(list= ls())
data <- import(here("datos", "Data.xlsx"), which = "hoja1") 

# Asignar valor 1 si estamos en democracia, 0 caso contrario
data <- data %>% mutate(demo = ifelse(year>=1990,1,0))
table(data$demo)

# Tabla 1: ¿Cual fue el pib promedio en democracia y en dictadura?
tabla1 <- data %>% group_by(demo) %>% 
                   summarize(promediopib = mean(gdp, na.rm = TRUE)) 
tabla1 

# Asignar valor 1 si estamos en democracia y el pib es mayor a su media
data <- data %>%  mutate(avance = ifelse(demo == 1 & gdp > mean(gdp),
                                         1,0))
mean(data$gdp)

# Asignar valor 1 si estamos en democracia y si dentro de esos periodos
# las exportaciones netas son mayores a la mediana de las importaciones 
data$expo <-ifelse(data$demo==1, ifelse(data$gross_exports>
                                          median(data$gross_imports),1,0),0)
table(data$expo)
```

::: {.alert .alert-block .alert-warning}
<b>Ejercicio 2.5.1:</b> Escriba lo anterior utilizando mutate.
:::

Respuesta:

```{r}
data <- data %>% mutate(expo = ifelse(demo==1, 
                                      ifelse(gross_exports>
                                          median(gross_imports),1,0),0))
```

#### Crear variables categóricas

También podemos crear variables categóricas utilizando `ifelse()`. De
manera muy sencilla podemos generar variables según ciertas condiciones:

```{r}
# De manera muy sencilla podemos generar variables según ciertas condiciones  
data$tipo<-ifelse(data$year<1980 & data$year>1959,1,
                  ifelse(data$year<2000 & data$year>1979,2,
                         ifelse(data$year<2010 & data$year>1999,3,4)
                  )
)
table(data$tipo)  

#  Nota: no es recomendable utilizar o escribir tantos `ifelse()` juntos.
# Es mejor utilizar `case_when()` que veremos un más adelante. 
```

### Factores

R puede codificar automáticamente una variable categorica (factor) con
un número entero. Sirven para hacer estadisticas o estimar regresiones.
Los factores, pueden ser ordenados o no ordenados, se utilizan para
representar variables que se agrupan en categorías.

Veamos un ejemplo:

```{r}
x <- rep(c("Ford","BMW","Peugeot"),10)
x

class(x)

# `factor()`
factor_nominal <- factor(x)
factor_nominal
class(factor_nominal)
levels(factor_nominal) #para analizar que niveles tiene el objeto
table(factor_nominal)  # resume la cantidad de observaciones por nivel
```

### Funciones útiles para transformar bases de datos

`across()`: Algunas veces queremos aplicar una función a múltiples
variables, para ello vamos a utilizar la función `across()` y
especificar la función con `fns`. Por ejemplo:

```{r}
datos2 <- data %>% 
          mutate(across(cols = everything(), fns = as.numeric))

# Aquí `across()`, que es una función de "dplyr", permite ser utilizada con `mutate()`, `select()`, `filter()`, `summarise()`, etc. 
datos3 <- data %>% 
  mutate(across(.cols = contains("gross"), .fns = as.numeric))
```

`cumsum()`: Suma acumulada

```{r}
# Para hacer operaciones acumuladas
sum(c(2,4,15,10))     # Retorna la suma del vector
cumsum(c(2,4,15,10))  # Retorna la suma acumulada del vector

# Puedo utilizarla con mutate ()
datos_acumulados <- data %>% 
  arrange(year) %>% 
  count(gdp) %>% 
  mutate(gdp_acumulado = cumsum(n))
datos_acumulados
```

Recodificar variables: A continuación se presentan algunos escenarios en
los que es necesario recodificar (cambiar) los valores:

1.  Editar un valor específico (por ejemplo, una fecha con un año o
    formato incorrecto)
2.  Para conciliar valores que no se escriben igual
3.  Crear una nueva columna de valores categóricas
4.  Crear una nueva columna de categorías numéricas (por ejemplo,
    categorías de edad)

`recode ()`: Cambiar valores

```{r}
rm(list= ls())
data <- import(here("datos", "Data.xlsx"), which = "hoja1") 
data <- data %>% mutate(demo = ifelse(year>=1990,1,0))

# Seguimos con data 
names(data)

# Creamos una nueva variable 
datos <- data %>% mutate(regimen = ifelse(demo == 1, "Democracia", "Dictadura"))
datos 

# Recodificamos (cambiar nombres)
datos <- datos %>% 
         mutate(regimen = recode(regimen, "Democracia" = "Demo", 
                          "Dictadura" = "Dict"))
datos 

# Notar que es vieja variable por nueva variable
```

`replace()`: Reemplazar valores

```{r}
datos <- datos %>%  mutate(avance = ifelse(demo == 1 & gdp > mean(gdp),
                                           1,0))

# Similar sintaxis a la de recode
datos <- datos %>% 
         mutate(regimen = replace(regimen, avance == 0, "No cambio en el pib"))

# Sintaxis
# mutate(columna a cambiar = replace(columna a cambiar, 
#                                      criterio para las filas, 
#                                      nuevo valor)).

# Un equivalente a `replace()` es utilizar []. 
datos$regimen[datos$avance == 0] <- "No cambio en el pib"
```

`replace_na()`: Para cambiar los valores perdidos (NA) por un valor
específico, como "Missing", utilice la función `dplyr` `replace_na()`
dentro de `mutate()`:

```{r}
datos_ficticios <- data.frame(var1 = c(seq(1,10), NA),
                              var2 = c(rep(NA,11)))
datos_ficticios

datos_ficticios1 <- datos_ficticios %>% 
                    mutate(var1 = replace_na(var1, 0))
datos_ficticios1
```

::: {.alert .alert-block .alert-danger}
<b>Recordatorio:</b> Esta función cambia los missing values solo por
valores de la misma clase de la variable/columna, por lo tanto, si
trabajamos con valores de clase numérica los reemplazos deben ser
también numéricos.
:::

`case_when()`: una función de `dplyr`. Es útil para asignar múltiples
valores. Sirve si se necesita recodificar muchos grupos:

```{r}
rm(list = ls())

datosedad <- data.frame(edad = c(2,3,4,1,500,2330,8,10,12), 
                        unidad = c("años","años", "años", NA, "meses", "meses", 
                                   "años", "años", "semanas"))
datosedad

# Imaginemos que queremos tener una medida comparable de edad, para ello
# podemos utilizar `case_when()`. 
datos_case_when <-  datosedad %>% 
  mutate(edad_años = case_when(
    unidad == "años"  ~ edad, 
    unidad == "meses" ~ edad/12, 
    unidad == "semanas" ~ edad/52, 
    is.na(unidad) ~ edad))

datos_case_when
```

### Cambio de formato de los datos

#### De ancho a largo

En en siguiente ejemplo, los datos están guardaos en "wide" para las
columnas que tienen el número de casos de malaria por tramos de edad.
Para un trabajo de análisis de datos es importante transformar los datos
a "long".

```{r}
rm(list = ls())
count_data <- import(here("datos","malaria_facility_count_data.rds"))
head(count_data)
```

`pivot_longer()`: función del paquete `tidyr`. Paquete incluido en
`tidyverse()`. Transforma los datos de wide a long.

```{r}
df_long <- count_data %>% 
  pivot_longer(
    cols = c("malaria_rdt_0-4", 
             "malaria_rdt_5-14", 
             "malaria_rdt_15", 
             "malaria_tot")
  )

df_long 

# Una mejor opción es con la función starts_with(): 
count_data %>% 
  pivot_longer(
    cols = starts_with("malaria_")
  )

# Para agregar nombres a las nuevas variable creadas
df_long1 <- count_data %>% 
  pivot_longer(
    cols = starts_with("malaria_"),
    names_to = "grupo_edad",
    values_to = "casos_malaria"
  )

df_long1
```

#### De largo a ancho

`pivot_wider()`: Transforma los datos de long a wide. Útil si quiero
hacer una tabla mas amigable para el o la lectora.

```{r}
rm(list = ls())
linelist <- import(here("datos","linelist_cleaned.rds"))

 df_wide <- linelist %>%
   count(age_cat, gender)
 df_wide

# En un mejor formato
 table_wide <- df_wide %>%
  pivot_wider(
     id_cols = age_cat,
     names_from = gender,
     values_from = n
   )

 table_wide
```

Otra opción para hacer esto mismo es `gather()` y `spread()`:

```{r}
rm(list = ls())
datos <- import(here("datos","Cuadro_1.xls"), skip = 1) 

# Cargamos datos que estan en formato ancho y los preparamos un poco...
datos <- datos[-c(1:2)]  
colnames(datos) <- c(1960:2018)
colnames(datos)

# 1. Como vemos, los años estan en las columnas, y queremos pasar a long data, 
# de forma tal que los años esten en una columna y el pib en otra 
# 2. La funciom "gather()" transforma los datos de formato ancho (wide) a 
# formato largo (long)

# De ancho a largo: utilizando la función gather()
# La primera es la variable "clave" y la segunda es la del valor
data_long <- datos %>% 
  gather(año, pib, 1:59)
data_long

# De largo a ancho: utilizando la función spread()
data_wide <- data_long %>% 
  spread(año,pib)
data_wide
```

### Juntar bases de datos

#### Pegar hacia el lado (por columnas)

En el siguiente ejemplo, tenemos datos de hospitales.

```{r}
rm(list = ls())
hosp_info <- import(here("datos","hosp_info_final.xlsx"))
linelist_mini <- import(here("datos","linelist_mini_final.xlsx"))
```

Sintaxis: Imaginemos que tenemos dos bases de datos "df1", "df2". df1
tienen una columna llamada "ID". df2 tiene una columna que se llama
identificador.

```{r}
# Caso 1: nombres de identificadores distintos.
data_junta <- join(df1,
                   df2,
                   by = c("ID" = "identificador"))

# Caso 2: imaginemos ambas bases de datos (df1, df2) tienen un
#         identificador llamado "ID"

data_junta <- join(df1,
                        df2,
                        by = "ID")

# Caso 3: imaginemos queremos pegar bases de datos considerando más
#         de un identificador.
data_junta <- join(df1, df2, by = c("nombre" = "primernombre",
                                         "apellido" = "primerapellido",
                                         "Edad" = "edad"))
```

**Left y Right join:**

```{r}
# Left join: la primera base de datos que aparece es la referencia.
# Right join: la segunda base de datos que aparece es la referencia.

# Left_join
left_join_ex1 <- left_join(linelist_mini,
                           hosp_info,
                           by = c("hospital" = "hosp_name"))


right_join_ex1 <- right_join(hosp_info,
                             linelist_mini,
                             by = c("hosp_name" = "hospital"))

# Ambos son equivalentes. 
right_join_ex2 <- right_join(linelist_mini,
                             hosp_info,
                             by = c("hospital" = "hosp_name"))

left_join_ex2 <- linelist_mini %>%
  left_join(hosp_info,
            by = c("hospital" = "hosp_name"))

# Notas:

# 1. Todas las filas/observaciones de la base de datos de referencia
#    se mantienen.
# 2. Si hay más de un match, se duplican las observaciones.
# 3. Los identificadores se combinan. Según el nombre
#     de la columna de la base de datos de referencia.
# 4. Cuando no hay un "match" las columnas se llenan con un NA
#     para las observaciones de la base de referencia.
# 5. No "match" por la base que no es de referencia se borran.
```

**Full Join:** El más inclusivo de los "joins". Retorna todas las
observaciones/filas:

```{r}
full_join_ex3 <- full_join(linelist_mini,
                           hosp_info,
                           by = c("hospital" = "hosp_name"))

full_join_ex3 <- linelist_mini %>%
  full_join(hosp_info,
            by = c("hospital" = "hosp_name"))
```

**Inner join:** El más restrictivo de los "join". Retorna solo las filas
que hicieron match entre ambas bases de datos.

```{r}
# Su análogo en stata es:  merge 1:1, keep _merge==3
# Los que se pegaron perfectamente entre ambas bases.

inner_join_example <- linelist_mini %>%
  inner_join(hosp_info,
             by = c("hospital" = "hosp_name"))
```

**Semi - join:** Mantiene todas las observaciones de la base de
referencia que tengan un "match" en la base secundaria, pero NO agrega
nuevas columnas ni duplicados en casos de multiples "match".

```{r}
semi_join_example1 <- semi_join(hosp_info, linelist_mini, 
                                by = c("hosp_name" ="hospital"))


semi_join_example <- hosp_info %>%
                     semi_join(linelist_mini,
                     by = c("hosp_name" = "hospital"))
```

**Anti- join:** Se le llama, al igual que semi-join "join de filtros".
Retorna las observaciones/filas en la base de datos de referencia que no
hacen "match" en base de datos secundaria.

```{r}
anti_join_example <- hosp_info %>%
  anti_join(linelist_mini,
            by = c("hosp_name" = "hospital"))
```

La función `merge`:

```{r}
rm(list = ls())

authors <- data.frame(
  surname = (c("Tukey", "Venables", "Tierney", "Ripley", "McNeil")),
  nationality = c("US", "Australia", "US", "UK", "Australia"),
  deceased = c("yes", rep("no", 4)))
authors

books <- data.frame(
  name = (c("Tukey", "Venables", "Tierney",
             "Ripley", "Ripley", "McNeil", "R Core")),
  title = c("Exploratory Data Analysis",
            "Modern Applied Statistics ...",
            "LISP-STAT",
            "Spatial Statistics", "Stochastic Simulation",
            "Interactive Data Analysis",
            "An Introduction to R"),
  other.author = c(NA, "Ripley", NA, NA, NA, NA,
                   "Venables & Smith"))
books

m0 <- merge(authors,
            books,
            by.x = "surname", by.y = "name")
m0

# Por defecto solo mantiene las que hicieron match.
m1 <-  merge(authors,
             books,
             by.x = "surname", by.y = "name", all = TRUE)
m1
```

#### Pegar hacia abajo (por filas)

Otra forma de unir bases de datos es agregar filas. Similar a lo que se
hace con `append()` en Stata. Vamos a utilizar la función `bind_rows()`
desde el paquete "dplyr".

1.  `bind_rows()` es bastante inclusivo. Cualquier columna presente en
    las bases de datos se incluye en el output.
2.  Si ambas columnas se llaman igual, se alinearan correctamente.
3.  Adicionalmente, podemos agregar el argumento `.id=`. Este argumento
    genera una nueva columna que sirve para identificar de donde
    proviene la informacion.

**Ejemplo 1:** caso sencillo

```{r}
continente_resumen <- gapminder %>%
  group_by(continent) %>%
  summarise(
    cases = n(),
    gdpPercapmedian = median(gdpPercap, na.rm = TRUE))
continente_resumen

# Crear Tabla 2: sin agrupar
totales <- gapminder %>%
  summarise(
    cases = n(),
    gdpPercapmedian =  median(gdpPercap, na.rm=T)
  )
totales

# Ahora las podemos pegar
combinadas <- bind_rows(continente_resumen, totales)
combinadas

# ¿Como cambiar ese NA? 
combinadas <- combinadas %>% 
              mutate(continent = replace_na("total"))
combinadas

# Muy util colocar "id"
combinadas_id <- bind_rows(continente_resumen, 
                           totales, 
                           .id = "id")
combinadas_id
```

**Ejemplo 2:** ¿Qué ocurre si hay más de un archivo?

```{r}
# Base de datos maestra
trial <- data.frame(
  year    = c(2016, 2017, 2018, 2019),
  n       = c(501, 499, 498, 502),
  outcome = c(51, 52, 49, 50)
) %>%
  print()

# Base de datos 1
trial_2020 <- data.frame(
  year    = 2020,
  n       = 500,
  outcome = 48
) %>%
  print()

# Base de datos 2
trial_2021 <- data.frame(
  year      = 2021,
  n         = 598,
  outcome   = 57
) %>%
  print()

# Para combinar mas de una base de datos
trial1<- bind_rows(trial,trial_2020, trial_2021)
```

**Ejemplo 3:** ¿Qué ocurre si tengo muchos archivos?

```{r}
rm(list=ls())
library(pacman)
p_load(plyr)    # Recomendable ocupar paquete plyr.

allfiles <- list.files(path = "datos",
                       pattern = ".csv",
                       full.names = TRUE)
allfiles

# Append data
combined_data<- ldply(allfiles, read_csv)
combined_data

# Transformar a un data.frame.
combined_data_sep <- separate(data = combined_data,
                              col = "year;n;outcome",
                              into = c("year", "n", "outcome"),
                              sep = ";")
combined_data_sep
```


